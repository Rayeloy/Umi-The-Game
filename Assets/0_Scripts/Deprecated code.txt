//PlayerMovement ProcessWallJump
{
            //CHECK IF WE ARE STILL ON THE WALL 
            //(since we are sliding off we will eventually have no more wall to hang from)

            /*if (lastWall == controller.collisions.horWall)
            {
                bool success = false;
                if (wallJumpRaycastAxis == Raycast.Axis.X)
                {
                    for (int i = 0; i < controller.collisions.horRaycastsX.GetLength(0) && !success; i++)
                    {
                        for (int j = 0; j < controller.collisions.horRaycastsX.GetLength(1) && !success; j++)
                        {
                            if (controller.collisions.horRaycastsX[i, j].axis == Raycast.Axis.X && controller.collisions.horRaycastsX[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                            {
                                success = true;
                                Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                            }
                        }
                    }
                }
                else if (wallJumpRaycastAxis == Raycast.Axis.Z)
                {
                    for (int i = 0; i < controller.collisions.horRaycastsZ.GetLength(0) && !success; i++)
                    {
                        for (int j = 0; j < controller.collisions.horRaycastsZ.GetLength(1) && !success; j++)
                        {
                            if (controller.collisions.horRaycastsZ[i, j].axis == Raycast.Axis.Z && controller.collisions.horRaycastsZ[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                            {
                                success = true;
                                Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                            }
                        }
                    }
                }
            }
            else if (lastWall == controller.collisions.verWall)
            {
                bool success = false;
                for (int i = 0; i < controller.collisions.verRaycastsY.GetLength(0) && !success; i++)
                {
                    for (int j = 0; j < controller.collisions.verRaycastsY.GetLength(1) && !success; j++)
                    {
                        if (controller.collisions.verRaycastsY[i, j].axis == Raycast.Axis.Y && controller.collisions.horRaycastsX[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                        {
                            success = true;
                            Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                        }
                    }
                }
            }
            else
            {
                Debug.Log("WallJump: StopWallJump, this wall (hor:" + controller.collisions.horWall + "; ver: "+ controller.collisions.verWall + ")is not the same wall that I started walljumping from (" + lastWall + ").");
                StopWallJump();
            }*/
}



void VerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "CAPSULE" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 RowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 RowOrigin = RowsOrigin;
        //float radius = 0f;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            RowOrigin.z =RowsOrigin.z + (verticalRowSpacing*i);
            //radius = i * verticalRadiusSpacing;
            //print("i= " + i + "; Radius = " + radius);
            //circleOrigin = new Vector3(circleOrigin.x, circleOrigin.y, circleOrigin.z + (i * verticalRadiusSpacing));

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                float angle = (j * verticalRayAngleSpacing) * Mathf.Deg2Rad;
                float px = circleOrigin.x + radius * Mathf.Cos(angle);
                float pz = circleOrigin.z + radius * Mathf.Sin(angle);
                Vector3 rayOrigin = new Vector3(px + vel.x, circleOrigin.y, pz + vel.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt != ClimbingState.descending || slopeAngle > maxDescendAngle)
                    {
                        //print("VERTICAL COLLISIONS");
                    vel.y = (hit.distance - skinWidth) * directionY;
                    rayLength = hit.distance;

                    if (collisions.moveSt == ClimbingState.climbing)
                    {
                        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    collisions.below = directionY == -1;
                    collisions.above = directionY == 1;
                    }
                }
            }
            if (collisions.climbSt == ClimbingState.climbing && collisions.slopeAngle != collisions.slopeAngleOld)//new slope, being on a slope already.This avoids going into the slope b4 adapting to new slope.
            {
                Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                rayLength = horVel.magnitude + skinWidth;
                Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;//NEEDS TO BE FIXED, the real ray origin should be  = BottomCenter + horVel.normalized * radius - skinWidth;
                RaycastHit hit;
                if (Physics.Raycast(rayOrigin, horVel.normalized, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                    if (slopeAngle != collisions.slopeAngle)
                    {
                        Vector3 newHorVel = (hit.distance - skinWidth) * horVel.normalized;
                        collisions.slopeAngle = slopeAngle;
                    }
                }
            }
        }
    }
	
	
    void NewHorizontalCollisions(ref Vector3 vel)
    {
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            float slopeAngle = GetSlopeAngle(hit);
                            float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }

                    }
                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            float slopeAngle = GetSlopeAngle(hit);
                            float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                    }
                }
            }
        }

        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = collisions.closestHorRaycast.row == 0 ? CheckSlopeType(ref vel, collisions.closestHorRaycast) : MovingState.wall;
            print("COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                case MovingState.wall:
                    //horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                    //vel = new Vector3(horVel.x, vel.y, horVel.z);

                    //float distanceToWall = 0;
                    if (collisions.wallAngleOld != collisions.closestHorRaycast.wallAngle)
                    {
                        print("APPROACHING WALL: " + "distance = " + collisions.closestHorRaycast.distance);
                        horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        collisions.wallAngle = collisions.closestHorRaycast.wallAngle;
                        /*distanceToWall = collisions.closestHorRaycast.distance - skinWidth;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToWall);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);*/
                    }
                    else
                    {
                        SlideWall(ref vel, collisions.closestHorRaycast);
                    }
                    /*horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToWall);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);*/

                    if (collisions.lastmoveSt == MovingState.climbing)
                    {
                        collisions.moveSt = MovingState.climbing;
                        vel.y = Mathf.Tan(collisions.slopeAngleOld * Mathf.Deg2Rad) * horVel.magnitude;
                    }
                    switch (collisions.closestHorRaycast.axis)
                    {
                        case Raycast.Axis.X:
                            collisions.left = directionX == -1;
                            collisions.right = directionX == 1;
                            break;
                        case Raycast.Axis.Z:
                            collisions.behind = directionZ == -1;
                            collisions.foward = directionZ == 1;
                            break;
                    }
                    break;
                case MovingState.climbing:
                    Raycast hit = MovingDirHorizontalCollisions(ref vel);
                    if (hit.axis != Raycast.Axis.none)//Physics.Raycast(collisions.closestHorRaycast.origin, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                        Debug.DrawRay(hit.origin, horVel * rayLength, Color.cyan, 4);
                        float distanceToSlopeStart = 0;
                        if (collisions.slopeAngleOld != collisions.closestHorRaycast.slopeAngle)
                        {
                            //RaycastHit hit;
                            //Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * rayLength, Color.white);
                            distanceToSlopeStart = hit.distance - skinWidth;
                            horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        ClimbSlope(ref vel, collisions.closestHorRaycast);
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    else
                    {
                        Debug.LogWarning("COULDNT HIT SLOPE to check for distance");
                    }
                    break;
                case MovingState.descending:
                    break;
                case MovingState.none:
                    break;
            }
        }
    }
	
	    Raycast MovingDirHorizontalCollisions(ref Vector3 vel)
    {
        Raycast result = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                RaycastHit hit;
                Debug.DrawRay(rayOriginX, horVel * rayLength, Color.red,1);

                if (Physics.Raycast(rayOriginX, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, 0);
                    }


                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                RaycastHit hit;
                Debug.DrawRay(rayOriginZ, horVel * rayLength, Color.red,1);

                if (Physics.Raycast(rayOriginZ, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, 0);
                    }

                }
            }
        }
        MovingState value = CheckSlopeType(ref vel, result);
        if (value == MovingState.climbing)
        {
            return result;
        }
        else
        {
            return new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        }

    }
	    void NewHorizontalCollisions(ref Vector3 vel)
    {
        Raycast wallRay = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }
                        if (slopeAngle > maxClimbAngle && hit.distance < wallRay.distance)
                        {
                            wallRay = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }

                    }
                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                        if (slopeAngle > maxClimbAngle && hit.distance < wallRay.distance)
                        {
                            wallRay = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                    }
                }
            }
        }

        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = collisions.closestHorRaycast.row == 0 ? CheckSlopeType(ref vel, collisions.closestHorRaycast) : MovingState.wall;
            print("COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                case MovingState.wall:
                    //horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                    //vel = new Vector3(horVel.x, vel.y, horVel.z);

                    //float distanceToWall = 0;
                    if (collisions.wallAngleOld != collisions.closestHorRaycast.wallAngle)
                    {
                        print("APPROACHING WALL: " + "distance = " + collisions.closestHorRaycast.distance);
                        horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        collisions.wallAngle = collisions.closestHorRaycast.wallAngle;
                        /*distanceToWall = collisions.closestHorRaycast.distance - skinWidth;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToWall);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);*/
                    }
                    else
                    {
                        WallSlide(ref vel, collisions.closestHorRaycast,false);
                    }
                    /*horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToWall);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);*/

                    /*if (collisions.lastMoveSt == MovingState.climbing)
                    {
                        collisions.moveSt = MovingState.climbing;
                        vel.y = Mathf.Tan(collisions.slopeAngleOld * Mathf.Deg2Rad) * horVel.magnitude;
                    }*/
                    switch (collisions.closestHorRaycast.axis)
                    {
                        case Raycast.Axis.X:
                            collisions.left = directionX == -1;
                            collisions.right = directionX == 1;
                            break;
                        case Raycast.Axis.Z:
                            collisions.behind = directionZ == -1;
                            collisions.foward = directionZ == 1;
                            break;
                    }
                    break;
                case MovingState.climbing:
                    Raycast hit = MovingDirHorizontalCollisions(ref vel);
                    if (hit.axis != Raycast.Axis.none)//Physics.Raycast(collisions.closestHorRaycast.origin, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                        Debug.DrawRay(hit.origin, horVel * rayLength, Color.cyan, 4);
                        float distanceToSlopeStart = 0;
                        if (collisions.slopeAngleOld != collisions.closestHorRaycast.slopeAngle)
                        {
                            //RaycastHit hit;
                            //Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * rayLength, Color.white);
                            distanceToSlopeStart = hit.distance - skinWidth;
                            horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        ClimbSlope(ref vel, collisions.closestHorRaycast);
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        if (wallRay.axis != Raycast.Axis.none)
                        {

                        }
                    }
                    else
                    {
                        Debug.LogWarning("COULDNT HIT SLOPE to check for distance");
                    }
                    break;
                case MovingState.descending:
                    break;
                case MovingState.none:
                    break;
            }
        }
    }//No se usa

    void NewVerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "Cube" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 rowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j), rowOrigin.y, rowOrigin.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    //print("Vertical Hit");
                    if (hit.distance < collisions.closestVerRaycast.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        collisions.closestVerRaycast = new Raycast(hit, hit.distance, vel, rayOrigin, slopeAngle, wallAngle, Raycast.Axis.Y, i);
                    }
                }
            }
        }
        if (collisions.closestVerRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = CheckSlopeType(ref vel, collisions.closestVerRaycast);
            //print("COLLISION VER: " + value + "; slopeAngle=" + collisions.closestVerRaycast.slopeAngle);
            if (value == MovingState.climbing)
            {
                value = MovingState.none;
            }
            //print("COLLISION " + value + "; slopeAngle=" + collisions.closestVerRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? suelo/cuesta arriba/cuesta abajo
            {
                case MovingState.none:
                    vel.y = (collisions.closestVerRaycast.distance - skinWidth) * directionY;
                    rayLength = collisions.closestVerRaycast.distance;
                    if (collisions.moveSt == MovingState.climbing)//Subiendo chocamos con un techo
                    {
                        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    collisions.below = directionY == -1;
                    collisions.above = directionY == 1;
                    break;
                case MovingState.climbing:
                    break;
                case MovingState.descending:
                    if (collisions.moveSt != MovingState.climbing)
                    {
                        float distanceToSlopeStart = 0;
                        //print("NEW SLOPE DESCENDING slope angle= " + collisions.closestVerRaycast.slopeAngle + "; hit point =" + collisions.closestVerRaycast.ray.point.ToString("F4"));
                        distanceToSlopeStart = collisions.closestVerRaycast.distance - skinWidth;
                        vel.y -= distanceToSlopeStart * -1;
                        print("DESCEND SLOPE");
                        DescendSlope(ref vel, collisions.closestVerRaycast);
                        vel.y += distanceToSlopeStart * -1;
                    }
                    //--------------------- CHECK FOR NEXT SLOPE/FLOOR -------------------------------------
                    Vector3 horVelAux = new Vector3(vel.x, 0, vel.z);
                    rayLength = (Mathf.Abs(vel.y) + skinWidth);
                    Vector3 rayOrigin = collisions.closestVerRaycast.origin + horVelAux;
                    RaycastHit hit;
                    Debug.DrawRay(rayOrigin, Vector3.down * rayLength, Color.yellow, 4);
                    if (Physics.Raycast(rayOrigin, Vector3.down, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        //+print("HIT  with angle = " + slopeAngle);
                        Debug.DrawRay(rayOrigin, Vector3.down * rayLength, Color.magenta, 4);
                        if (slopeAngle != collisions.slopeAngle)
                        {
                            //print("HIT NEW SLOPE/FLOOR with angle = " + slopeAngle);
                            vel.y = -(hit.distance - skinWidth);
                            //vel = new Vector3(horVelAux.x, vel.y, horVelAux.z);
                            collisions.slopeAngle = slopeAngle;
                        }
                    }
                    break;
            }
        }
    }//No se usa

    Raycast MovingDirHorizontalCollisions(ref Vector3 vel)
    {
        Raycast result = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                rayOriginX += (Vector3.right * directionX * skinWidth);
                rayOriginX += (-horVel * skinWidth);
                RaycastHit hit;
                Debug.DrawRay(rayOriginX, horVel * rayLength, Color.yellow, 0.1f);

                if (Physics.Raycast(rayOriginX, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, 0);
                    }


                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                rayOriginZ += (Vector3.forward * directionZ * skinWidth);
                rayOriginZ += (-horVel * skinWidth);
                RaycastHit hit;
                Debug.DrawRay(rayOriginZ, horVel * rayLength, Color.yellow, 0.1f);

                if (Physics.Raycast(rayOriginZ, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, 0);
                    }

                }
            }
        }
        MovingState val = CheckSlopeType(ref vel, result);
        if (val == MovingState.climbing)
        {
            return result;
        }
        else
        {
            return new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        }

    }//No se usa

    void HorizontalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D CAPSULE -------------------
        float directionX = Mathf.Sign(vel.x);
        float directionZ = Mathf.Sign(vel.z);

        Vector3 dirXZ = new Vector3(vel.x, 0, vel.z);
        //PERPENDICULAR VECTOR TO MOVING DIR
        float perpX = 1;
        float perpZ = (-dirXZ.x / dirXZ.z) * perpX;
        Vector3 perpVector = new Vector3(perpX, 0, perpZ).normalized;
        Vector3 rowDir = -perpVector;

        float rayLength = Mathf.Abs(dirXZ.magnitude) + skinWidth;
        //CIRCUMFERENCE POINT THAT INTERSECTS WITH dirXZ THAT CROSSES CENTER
        Vector3 rowsOriginCenter = dirXZ.normalized * (horizontalRadius - skinWidth);
        float rx = rowsOriginCenter.x + raycastOrigins.BottomCenterH.x;
        float rz = rowsOriginCenter.z + raycastOrigins.BottomCenterH.z;
        rowsOriginCenter = new Vector3(rx, raycastOrigins.BottomCenterH.y, rz);
        //CIRCUMFERENCE POINT THAT INTERSECTS WITH PERPENDICULAR VECTOR THAT CROSSES CENTER
        /*float angle = Mathf.Acos(((1 * perpVector.x) + (0 * perpVector.z)) / (1 * perpVector.magnitude)) * Mathf.Rad2Deg;
        float px = raycastOrigins.BottomCenter.x + horizontalRadius * Mathf.Cos(angle);
        float pz = raycastOrigins.BottomCenter.z + horizontalRadius * Mathf.Sin(angle);
        Vector3 rowsOrigin = new Vector3(px, raycastOrigins.BottomCenter.y, pz);*/
        Vector3 rowsOrigin = perpVector * (horizontalRadius);
        rx = rowsOrigin.x + rowsOriginCenter.x;
        rz = rowsOrigin.z + rowsOriginCenter.z;
        rowsOrigin = new Vector3(rx, rowsOriginCenter.y, rz);
        //print("dirXZ=" + dirXZ.ToString("F4") + "; perpVector=" + perpVector + ";rowsOrigin="+rowsOrigin);
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = new Vector3(rowsOrigin.x, rowsOrigin.y + (i * horizontalRowSpacing), rowsOrigin.z);
            //print("horizontalRowSpacing= " + horizontalRowSpacing + "; rowOrigin = " + rowOrigin.ToString("F4"));
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                //o=(rowOrigin.x,rowOrigin.z), f=(fx,fz), r=(perpVector2.x,perpVector2.z)
                //(perpVector2.x,perpVector2.z)=(fx-rowOrigin.x,fz-rowOrigin.z)
                Vector3 finalRowDir = rowDir * (j * horizontalRaySpacing);
                float fx = finalRowDir.x + rowOrigin.x;
                float fz = finalRowDir.z + rowOrigin.z;
                Vector3 rayOrigin = new Vector3(fx, rowOrigin.y, fz);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, dirXZ * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, dirXZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    //print("HIT AGAINST " + hit.collider.gameObject.name);
                    //print("DISTANCE HIT = " + hit.distance);
                    if (hit.distance > (skinWidth))
                    {
                        print("HIT DISTANCE= " + hit.distance);
                        Vector3 aux = dirXZ.normalized * (hit.distance - skinWidth);
                        vel = new Vector3(aux.x, vel.y, aux.z);
                        rayLength = hit.distance;
                    }
                    else
                    {
                        //calculate parallel direction to plane hit and percentage of magnitude, based on incidence angle (90º->0)
                        Vector3 normal = new Vector3(hit.normal.x, 0, hit.normal.z);
                        Vector3 parallel = -normal;
                        //angle
                        float cos = Vector3.Dot(dirXZ, normal);
                        float cosDeg = Mathf.Acos(cos) * Mathf.Rad2Deg;
                        float prop = ((cosDeg - 90) / 90);
                        prop = Mathf.Clamp(prop, 0, 1);
                        float finalSpeed = vel.magnitude * prop;
                        vel = new Vector3(parallel.x * finalSpeed, vel.y, parallel.z * finalSpeed);
                        print("HIT ANGLE = " + cosDeg + "; PARALLEL DIR= " + parallel.ToString("F4") + "; FINAL SPEED= " + finalSpeed);
                    }

                    collisions.behind = directionZ == -1;
                    collisions.foward = directionZ == 1;
                    collisions.left = directionX == -1;
                    collisions.right = directionX == 1;
                }
                //if (i == 0) { break; }
            }
        }
    }//No se usa

	    void VerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "CAPSULE" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 rowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);
            //print("i= " + i + "; Radius = " + radius);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j + vel.x), rowOrigin.y, rowOrigin.z + vel.z);

                RaycastHit hit;
                //Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt != MovingState.descending)
                    {
                        //print("VERTICAL COLLISIONS");
                        vel.y = (hit.distance - skinWidth) * directionY;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        collisions.below = directionY == -1;
                        collisions.above = directionY == 1;
                    }
                }
            }
            if (collisions.moveSt == MovingState.climbing && collisions.slopeAngle != collisions.slopeAngleOld)//new slope, being on a slope already.This avoids going into the slope b4 adapting to new slope.
            {
                Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                rayLength = horVel.magnitude + skinWidth;
                Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;//NEEDS TO BE FIXED, the real ray origin should be  = BottomCenter + horVel.normalized * radius - skinWidth;
                RaycastHit hit;
                if (Physics.Raycast(rayOrigin, horVel.normalized, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                    if (slopeAngle != collisions.slopeAngle)
                    {
                        Vector3 newHorVel = (hit.distance - skinWidth) * horVel.normalized;
                        collisions.slopeAngle = slopeAngle;
                    }
                }
            }
        }
    }//No se usa

    void XCollisions(ref Vector3 vel)
    {
        float directionX = Mathf.Sign(vel.x);
        float rayLength = Mathf.Abs(vel.x) + skinWidth;
        Vector3 rowsOrigin = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = rowsOrigin;
            rowOrigin.y = rowsOrigin.y + i * horizontalRowSpacing;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOrigin = rowOrigin + Vector3.back * (j * horizontalRaySpacing + vel.y);
                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.right * directionX * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt == MovingState.none || slopeAngle > maxClimbAngle)
                    {
                        vel.x = (hit.distance - skinWidth) * directionX;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            vel.y = Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(vel.x);
                        }
                        collisions.left = directionX == -1;
                        collisions.right = directionX == 1;
                    }

                }
            }
        }
    }//No se usa

    void ZCollisions(ref Vector3 vel)
    {
        float directionZ = Mathf.Sign(vel.z);
        float rayLength = Mathf.Abs(vel.z) + skinWidth;
        Vector3 rowsOrigin = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = rowsOrigin;
            rowOrigin.y = rowsOrigin.y + i * horizontalRowSpacing;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOrigin = rowOrigin + Vector3.right * (j * horizontalRaySpacing + vel.y);
                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.forward * directionZ * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt == MovingState.none || slopeAngle > maxClimbAngle)
                    {
                        vel.z = (hit.distance - skinWidth) * directionZ;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            vel.y = Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(vel.z);
                        }
                        collisions.behind = directionZ == -1;
                        collisions.foward = directionZ == 1;
                    }
                }
            }
        }
    }//No se usa

	
    void ClimbSlopeCollisions(ref Vector3 vel)
    {
        float directionX = Mathf.Sign(vel.x);
        float rayLengthX = skinWidth;
        Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
        for (int j = 0; j < horizontalRaysPerRow; j++)
        {
            Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
            RaycastHit hit;
            Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLengthX, Color.yellow);
            //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

            if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLengthX, collisionMask, QueryTriggerInteraction.Ignore))
            {
                float slopeAngle = GetSlopeAngle(hit);
                if (hit.distance < collisions.closestHorRaycast.distance)
                {
                    float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                    collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X);
                }
            }
        }
        float directionZ = Mathf.Sign(vel.z);
        float rayLengthZ = skinWidth;
        Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
        for (int j = 0; j < horizontalRaysPerRow; j++)
        {
            Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
            RaycastHit hit;
            Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLengthZ, Color.yellow);
            //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

            if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLengthZ, collisionMask, QueryTriggerInteraction.Ignore))
            {
                float slopeAngle = GetSlopeAngle(hit);
                if (hit.distance < collisions.closestHorRaycast.distance)
                {
                    float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                    collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z);
                }
            }
        }
        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)// En otras palabras, si se ha movido y rellenado el valor de "closestHorRaycast"(hit)
        {
            if (collisions.closestHorRaycast.slopeAngle <= maxClimbAngle)
            {
                Vector3 horVel;
                float distanceToSlopeStart = 0;
                if (collisions.closestHorRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
                {//Substract the distance to slope from the velocity
                    distanceToSlopeStart = collisions.closestHorRaycast.distance - skinWidth;
                    horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);
                }
                ClimbSlope(ref vel, collisions.closestHorRaycast);
                horVel = new Vector3(vel.x, 0, vel.z);
                horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                vel = new Vector3(horVel.x, vel.y, horVel.z);
            }
        }
    }//No se usa

    void DescendSlopeCollisions(ref Vector3 vel)
    {
        float directionY = Mathf.Sign(vel.y);
        float rayLength = 1 + skinWidth;
        Vector3 rowsOrigin = raycastOrigins.BottomLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);
            //print("i= " + i + "; Radius = " + radius);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j), rowOrigin.y, rowOrigin.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.yellow);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (hit.distance < collisions.closestVerRaycast.distance)
                    {
                        //print("NEW CLOSEST VERTRAY, slope angle= " + slopeAngle);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        collisions.closestVerRaycast = new Raycast(hit, hit.distance, vel, rayOrigin, slopeAngle, wallAngle, Raycast.Axis.Y);
                    }
                }
            }
        }

        if (collisions.closestVerRaycast.axis == Raycast.Axis.Y)// We are touching floor
        {
            if (CheckSlopeType(ref vel, collisions.closestVerRaycast) == MovingState.descending)
            {
                if (collisions.closestVerRaycast.slopeAngle <= maxDescendAngle)
                {
                    float distanceToSlopeStart = 0;
                    if (collisions.closestVerRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
                    {
                        print("NEW SLOPE DESCENDING slope angle= " + collisions.closestVerRaycast.slopeAngle + "; hit point =" + collisions.closestVerRaycast.ray.point.ToString("F4"));
                        distanceToSlopeStart = collisions.closestVerRaycast.distance - skinWidth;
                        vel.y -= distanceToSlopeStart * -1;
                    }
                    //print("DESCEND SLOPE");
                    DescendSlope(ref vel, collisions.closestVerRaycast);
                    vel.y += distanceToSlopeStart * -1;
                    //print("vel= " + vel.ToString("F5"));
                }
            }


            /*Vector3 horVel;
            float distanceToSlopeStart = 0;
            if (collisions.closestHorRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
            {//Substract the distance to slope from the velocity
                distanceToSlopeStart = collisions.closestHorRaycast.distance - skinWidth;
                horVel = new Vector3(vel.x, 0, vel.z);
                horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                vel = new Vector3(horVel.x, vel.y, horVel.z);
            }
            ClimbSlope(ref vel, collisions.closestHorRaycast);
            horVel = new Vector3(vel.x, 0, vel.z);
            horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
            vel = new Vector3(horVel.x, vel.y, horVel.z);*/
        }
    }//No se usa
	
    void CylinderHorizontalCollisions(ref Vector3 vel)
    {
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        Vector3 rowOrigin = raycastOrigins.BottomCenter + (horVel.normalized * raycastOrigins.AroundRadius);
        for (int i = 0; i < horizontalRows; i++)
        {
            rowOrigin.y = raycastOrigins.BottomCenter.y + (i * horizontalRowSpacing);
            //for(int j=0; j<)
        }
    }//No se usa

	    /*
     public void PickFlag(GameObject _flag)
     {
         Flag auxFlag = _flag.GetComponent<Flag>();
         GameObject ownerFlag = _flag.GetComponent<Flag>().currentOwner;
         if (ownerFlag == null)
         {
             if (!haveFlag && ((!auxFlag.beingHooked) || (auxFlag.beingHooked && auxFlag.playerHooking != transform)))
             {
                 flag = _flag;
                 flag.transform.SetParent(rotateObj);
                 flag.transform.localPosition = new Vector3(0, 0, -0.5f);
                 flag.transform.localRotation = Quaternion.Euler(0, -90, 0);
                 haveFlag = true;
                 ownerFlag = gameObject;
             }
         }
     }

     public void StealFlag(Transform _flag)
     {
         Flag auxFlag = _flag.GetComponent<Flag>();
         GameObject ownerFlag = auxFlag = 

     }

     public void LoseFlag(PlayerMovement attacker)
     {
         if (haveFlag)
         {
             print("ROBA BANDERA");
             attacker.PickFlag(flag);
             flag = null;
             haveFlag = false;
         }
     }

     public void LoseFlag()
     {
         if (haveFlag)
         {
             flag.GetComponent<Flag>().currentOwner = null;
             flag.transform.SetParent(StoringManager.instance.transform);
             flag = null;
             haveFlag = false;
         }
     }*/

	 //WALL EDGE:
	        //Debug.LogError("WALL EDGE: collPoint1 = " + collisions.closestHorRaycast.ray.point.ToString("F4") + "; collPoint2 = " + differentWallRay.ray.point.ToString("F4") +
            //    "; vector1 = " + vector1 + "; vector2 = " + vector2 + "; angle1 = " + angle1 + "; angle1 = " + angle2 + "; angle1IsRight = " + angle1IsRight);
            //float edgeAngle = Vector3.SignedAngle(differentWallRay.ray.normal, collisions.closestHorRaycast.ray.normal,Vector3.up);
            //edgeAngle = Mathf.Sign(edgeAngle)*((360 - (Mathf.Abs(edgeAngle) * 2) )/ 2);
            //float angle1 = differentWallRay.wallAngle;
            //angle1 = Vector3.Angle(Vector3.right, differentWallRay.ray.normal)>=90? angle1 : -angle1;
            //float angle2 = collisions.closestHorRaycast.wallAngle;
            //angle2 = Vector3.Angle(Vector3.right, collisions.closestHorRaycast.ray.normal) >= 90 ? angle2 : -angle2;
            //edgeAngle = SignedAngleBetween(differentWallRay.ray.normal, collisions.closestHorRaycast.ray.normal, Vector3.up);

            //Vector3 wallVector1 = new Vector3(-differentWallRay.ray.normal.z, 0, differentWallRay.ray.normal.x).normalized;
            //Vector3 wallVector2 = new Vector3(-collisions.closestHorRaycast.ray.normal.z, 0, collisions.closestHorRaycast.ray.normal.x).normalized;
            //Debug.DrawRay(differentWallRay.origin,wallVector1*2,Color.black,3);
            //Debug.DrawRay(collisions.closestHorRaycast.origin, wallVector2*2, Color.black, 3);
            //Debug.LogWarning("WALL EDGE: collided with walls with angles: "+ angle1 + " and "+ angle2 + "; wallAngles = "+ wallVector1 +" and "+ wallVector2 +
            //    "; angle between them = " + edgeAngle);
            //if (edgeAngle < 0)
            //{
            //}

			//WALL SLIDE AND NEW HORIZONTAL COLLISIONS 2

			
    /*bool SecondWallSlide(ref Vector3 vel, Raycast rayCast, Vector3 originalVel)
    {
        Debug.LogWarning("SECOND WALL SLIDE");
        Vector3 horVel = new Vector3(originalVel.x, 0, originalVel.z);
        float wallAngle = rayCast.wallAngle;
        Vector3 normal = -new Vector3(rayCast.ray.normal.x, 0, rayCast.ray.normal.z).normalized;
        float angle = Vector3.Angle(normal, horVel);
        float a = Mathf.Sin(angle * Mathf.Deg2Rad) * horVel.magnitude;
        Vector3 movementNormal = Vector3.up;
        Vector3 slideVel = Vector3.Cross(normal, movementNormal).normalized;
        //LEFT OR RIGHT ORIENTATION?
        float ang = Vector3.Angle(slideVel, horVel);
        slideVel = ang > 90 ? -slideVel : slideVel;
        //print("SLIDE ANGLE= " + angle + "; vel = " + vel + "; slideVel = " + slideVel.ToString("F4") + "; a = " + a + "; wallAngle = " + wallAngle + "; distanceToWall = " + rayCast.distance);
        slideVel *= a;
        SlideState slideSt = ang > 90 ? SlideState.right : SlideState.left;
        //print("------------SLIDE STATE ------------ = " + slideSt);
        if (slideSt == collisions.slideSt)
        {
            collisions.slideSt = slideSt;
            vel = new Vector3(slideVel.x, vel.y, slideVel.z);
            collisions.collSt = CollisionState.wall;
            collisions.wallAngle = wallAngle;
            if (!disableAllRays) Debug.DrawRay(raycastOrigins.Center, slideVel.normalized * 2, Color.green, 1);
            return true;
        }
        else
        {
            //Debug.LogWarning("-----------SECOND WALL SLIDE HAS WRONG DIRECTION---------- = " + slideSt);
            horVel = horVel * (rayCast.distance);
            vel = new Vector3(horVel.x, vel.y, horVel.z);
            collisions.wallAngle2 = rayCast.wallAngle;
            return false;
        }
    }*/

    /*void WallSlideCollisions(ref Vector3 vel)
    {

        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;
        Vector3 wallNormal = new Vector3(collisions.wallNormal.x, 0, collisions.wallNormal.z).normalized;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCornerReal : raycastOrigins.BottomLFCornerReal;
            //LEAVE SAFE SPACE FROM WALL 
            rowsOriginX += wallNormal * precisionSpaceFromSlideWall;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                //For drawing the character collider limits only
                Vector3 lastOriginX = rowOriginX;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                    if (showWallLimits && !disableAllRays)
                    {
                        Debug.DrawLine(lastOriginX, rayOriginX, Color.blue);
                    }
                    lastOriginX = rayOriginX;
                    rayOriginX += (-horVel * skinWidth);
                    RaycastHit hit;
                    if (showWallRays && !disableAllRays)
                    {
                        Debug.DrawRay(rayOriginX, horVel * rayLength, Color.yellow);
                    }

                    if (Physics.Raycast(rayOriginX, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycastSlide.distance && hit.transform.gameObject != collisions.horWall)
                        {
                            collisions.closestHorRaycastSlide = new Raycast(hit, hit.distance, vel, rayOriginX, true, slopeAngle, wallAngle, Axis.X, i, j, 0);
                        }
                    }
                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCornerReal : raycastOrigins.BottomLBCornerReal;
            //LEAVE SAFE SPACE FROM WALL 
            rowsOriginZ += wallNormal * precisionSpaceFromSlideWall;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                //For drawing the character collider limits only
                Vector3 lastOriginZ = rowOriginZ;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                    if (showWallLimits && !disableAllRays)
                    {
                        Debug.DrawLine(lastOriginZ, rayOriginZ, Color.blue);
                    }
                    lastOriginZ = rayOriginZ;
                    rayOriginZ += (-horVel * skinWidth);

                    RaycastHit hit;
                    //Debug.DrawRay(rayOriginZ, horVel * rayLength, Color.yellow);

                    if (Physics.Raycast(rayOriginZ, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycastSlide.distance && hit.transform.gameObject != collisions.horWall)
                        {
                            collisions.closestHorRaycastSlide = new Raycast(hit, hit.distance, vel, rayOriginZ, true, slopeAngle, wallAngle, Axis.Z, i, j, 0);
                        }
                    }
                }
            }
        }

        if (collisions.closestHorRaycastSlide.hit)//si ha habido una collision horizontal
        {
            CollisionState value = collisions.closestHorRaycastSlide.row == 0 ? CheckSlopeType(vel, collisions.closestHorRaycastSlide) : CollisionState.wall;
            //print("---------- SECOND COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycastSlide.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                #region --- Wall --- 
                case CollisionState.wall:
                    //check if the "wall" is not just the floor/really small ridge
                    bool validWall = true;
                    float heightToPrecisionHeight = precisionHeight - (collisions.closestHorRaycast.origin.y - raycastOrigins.BottomLBCornerReal.y);
                    if (heightToPrecisionHeight <= 0)
                    {
                        validWall = true;
                    }
                    else
                    {
                        Vector3 rayOriginAux = collisions.closestHorRaycast.origin + Vector3.up * heightToPrecisionHeight;
                        RaycastHit hitAux;
                        if (Physics.Raycast(rayOriginAux, horVel, out hitAux, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                        {
                            float slopeAngle = GetSlopeAngle(hitAux);
                            if (slopeAngle == collisions.closestHorRaycast.slopeAngle)
                            {
                                validWall = true;
                            }
                        }
                    }
                    if (validWall)
                    {
                        if (collisions.wallAngleOld2 != collisions.closestHorRaycastSlide.wallAngle)
                        {
                            //print("APPROACHING WALL: " + "distance = " + collisions.closestHorRaycastSlide.distance);
                            horVel = horVel * (collisions.closestHorRaycastSlide.distance);
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                            collisions.wallAngle2 = collisions.closestHorRaycastSlide.wallAngle;
                        }
                        else
                        {
                            if (SecondWallSlide(ref vel, collisions.closestHorRaycastSlide, collisions.closestHorRaycast.vel))
                            {
                                //collisions.horCollisionsPoint = collisions.closestHorRaycast.ray.point;
                                collisions.wallNormal = collisions.closestHorRaycast.ray.normal;
                                collisions.horWall = collisions.closestHorRaycast.ray.transform.gameObject;
                                switch (collisions.closestHorRaycast.axis)
                                {
                                    case Axis.X:
                                        collisions.left = directionX == -1;
                                        collisions.right = directionX == 1;
                                        break;
                                    case Axis.Z:
                                        collisions.behind = directionZ == -1;
                                        collisions.foward = directionZ == 1;
                                        break;
                                }
                            }
                        }
                    }
                    break;
                #endregion
                #region --- Climbing ---
                case CollisionState.climbing:
                    //print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                    if (!disableAllRays) Debug.DrawRay(collisions.closestHorRaycastSlide.origin, horVel * rayLength, Color.cyan, 4);

                    float distanceToSlopeStart = 0;
                    if (collisions.slopeAngleOld != collisions.closestHorRaycastSlide.slopeAngle)
                    {
                        distanceToSlopeStart = collisions.closestHorRaycastSlide.distance;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    ClimbSlope(ref vel, collisions.closestHorRaycastSlide);
                    horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);
                    //--------------------- CHECK FOR NEXT SLOPE/WALL -------------------------------------
                    Vector3 horVelAux = new Vector3(vel.x, 0, vel.z);
                    rayLength = (horVelAux.magnitude + skinWidth);
                    Vector3 rayOrigin = collisions.closestHorRaycastSlide.origin + Vector3.up * vel.y;
                    RaycastHit hit;
                    if (!disableAllRays) Debug.DrawRay(rayOrigin, horVelAux * rayLength, Color.yellow, 4);

                    if (Physics.Raycast(rayOrigin, horVelAux, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        //+print("HIT  with angle = " + slopeAngle);
                        if (!disableAllRays) Debug.DrawRay(rayOrigin, horVelAux * rayLength, Color.magenta, 4);

                        if (slopeAngle != collisions.slopeAngle)
                        {
                            //TO DO: CAMBIAR skinWidth
                            horVelAux = horVelAux.normalized * (hit.distance - skinWidth);
                            //tan(realAngle)=y/xz;
                            float y = vel.y;
                            if (slopeAngle > maxClimbAngle)//IF IT'S A WALL
                            {
                                y = Mathf.Tan(collisions.realSlopeAngle * Mathf.Deg2Rad) * horVelAux.magnitude;
                            }
                            vel = new Vector3(horVelAux.x, y, horVelAux.z);
                            print("HIT NEW SLOPE/Wall with angle = " + slopeAngle);
                            //vel = new Vector3(horVelAux.x, vel.y, horVelAux.z);
                            collisions.slopeAngle = slopeAngle;
                        }
                    }
                    break;
                    #endregion
            }
        }
    }*/

	    /*void NewHorizontalCollisions2(ref Vector3 vel)
    {
        #region Raycasts
        collisions.horRaycastsX = new Raycast[horizontalRows, horizontalRaysPerRow];
        collisions.horRaycastsZ = new Raycast[horizontalRows, horizontalRaysPerRow];
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);//DO NOT CHANGE ORDER
        float rayLength = horVel.magnitude + skinWidth;//DO NOT CHANGE ORDER
        horVel = horVel.normalized;//DO NOT CHANGE ORDER
        float directionX = 0, directionZ = 0;

        //VARIABLES FOR "Cutting Out Raycast's Skinwidth in Borders"
        float corsbAngle = 0;

        #region Raycasts X
        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCornerReal : raycastOrigins.BottomLFCornerReal;
            corsbAngle = Vector3.Angle(Vector3.forward, horVel);

            //print("CONTROLLER 3D: " + directionX + "*X corsbAngle = " + corsbAngle + "; corsbBorderHorRaysPerRow = " + corsbBorderHorRaysPerRow +
            //    "; (horizontalRaysPerRow - corsbBorderHorRaysPerRow) = " + (horizontalRaysPerRow - corsbBorderHorRaysPerRow));
            for (int i = 0; i < horizontalRows; i++)//ROWS
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                if (i == 0)
                {
                    rowOriginX += Vector3.up * skinWidthHeight;
                }
                else if (i == horizontalRows - 1)
                {
                    rowOriginX += Vector3.down * skinWidthHeight;
                }
                Vector3 lastOriginX = rowOriginX;
                for (int j = 0; j < horizontalRaysPerRow; j++)//COLUMNS
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);

                    #region --- CORSB SYSTEM ---
                    // --- CORSB SYSTEM ---    
                    //VARIABLES FOR CORSB
                    float corsbDistanceToBorder = 0;
                    float corsbSkinWidth = skinWidth;
                    float corsbRayLength = rayLength;

                    if (((j < corsbBorderHorRaysPerRow && corsbAngle > 90) || (j >= (horizontalRaysPerRow - corsbBorderHorRaysPerRow) && corsbAngle < 90)) && corsbOn)
                    {
                        float auxCorsbSkinWidth = float.MaxValue;
                        float auxAngle;
                        if (j < corsbBorderHorRaysPerRow && corsbAngle > 90)//primer 20% de rayos
                        {
                            auxAngle = 180 - corsbAngle;
                            corsbDistanceToBorder = (float)j * (float)horizontalRaySpacing;
                            //print("CONTROLLER 3D: CORSB system checking started (Part1)-> j = " + j + "; corsbDistanceToBorder = " + corsbDistanceToBorder);
                        }
                        else //último 20%
                        {
                            auxAngle = corsbAngle;
                            corsbDistanceToBorder = (float)(horizontalRaysPerRow - (j + 1)) * (float)horizontalRaySpacing;
                            //print("CONTROLLER 3D: CORSB system checking started (Part2)-> j = " + j + "; corsbDistanceToBorder = " + corsbDistanceToBorder);
                        }
                        auxCorsbSkinWidth = corsbDistanceToBorder / Mathf.Cos(auxAngle * Mathf.Deg2Rad);
                        //print("CONTROLLER 3D: CORSB system checking: i = " + i + "; j = " + j + "; corsbAngle = " + corsbAngle +
                        //    "; skinWidth = " + skinWidth + "; auxCorsbSkinWidth = " + auxCorsbSkinWidth + "; corsbDistanceToBorder = " +
                        //    corsbDistanceToBorder + "; Mathf.Cos(auxAngle * Mathf.Deg2Rad) = " + Mathf.Cos(auxAngle * Mathf.Deg2Rad));
                        if (auxCorsbSkinWidth < skinWidth)
                        {
                            corsbSkinWidth = auxCorsbSkinWidth;
                            corsbRayLength = rayLength - (skinWidth - auxCorsbSkinWidth);
                            //print("CONTROLLER 3D: CORSB system activated!");
                        }
                    }
                    // --- CORSB SYSTEM END ---
                    #endregion

                    if (showHorizontalLimits && !disableAllRays)
                    {
                        Debug.DrawLine(lastOriginX, rayOriginX, Color.blue);
                    }
                    lastOriginX = rayOriginX;
                    rayOriginX += (-horVel * corsbSkinWidth);
                    RaycastHit hit;
                    if (showHorizontalRays && !disableAllRays)
                    {
                        Debug.DrawRay(rayOriginX, horVel * corsbRayLength, (corsbSkinWidth < skinWidth ? corsbColor : Color.red));
                    }

                    if (Physics.Raycast(rayOriginX, horVel, out hit, corsbRayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = SignedRelativeAngle(Vector3.forward, hit.normal);// Vector3.Angle(hit.normal, Vector3.forward);
                        Raycast auxRay = new Raycast(hit, (hit.distance - corsbSkinWidth), vel, rayOriginX, true, slopeAngle, wallAngle, Axis.X,
                            i, j, horizontalRows, corsbSkinWidth);
                        //WE STORE ALL THE RAYCASTS INFO
                        collisions.horRaycastsX[i, j] = auxRay;

                        bool newClosestRay = IsCloserHorizontalRay(collisions.closestHorRaycast, auxRay);
                        if (newClosestRay)
                        {
                            collisions.closestHorRaycast = auxRay;
                        }
                        //Closest climbing ray
                        SaveClosestHorizontalClimbingRay(auxRay);
                    }
                    else
                    {
                        //WE STORE ALL THE RAYCASTS INFO
                        Raycast auxRay = new Raycast(hit, (hit.distance - corsbSkinWidth), vel, rayOriginX, false, 0, 0, Axis.X, i, j, horizontalRows, corsbSkinWidth);
                        collisions.horRaycastsX[i, j] = auxRay;
                    }
                }
            }
        }
        #endregion
        #region Raycasts Z
        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCornerReal : raycastOrigins.BottomLBCornerReal;
            corsbAngle = Vector3.Angle(Vector3.left, horVel);
            //print("CONTROLLER 3D: " + directionZ + "*Z corsbAngle = " + corsbAngle + "; corsbBorderHorRaysPerRow = " + corsbBorderHorRaysPerRow +
            //    "; (horizontalRaysPerRow - corsbBorderHorRaysPerRow) = " + (horizontalRaysPerRow - corsbBorderHorRaysPerRow)+ "; horizontalRaySpacing = " + horizontalRaySpacing);
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                if (i == 0)
                {
                    rowOriginZ += Vector3.up * skinWidthHeight;
                }
                else if (i == horizontalRows - 1)
                {
                    rowOriginZ += Vector3.down * skinWidthHeight;
                }
                Vector3 lastOriginZ = rowOriginZ;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);

                    #region --- CORSB SYSTEM ---
                    // --- CORSB SYSTEM ---    
                    //VARIABLES FOR CORSB
                    float corsbDistanceToBorder = 0;
                    float corsbSkinWidth = skinWidth;
                    float corsbRayLength = rayLength;

                    if (((j < corsbBorderHorRaysPerRow && corsbAngle > 90) || (j >= (horizontalRaysPerRow - corsbBorderHorRaysPerRow) && corsbAngle < 90)) && corsbOn)
                    {
                        float auxCorsbSkinWidth = float.MaxValue;
                        float auxAngle;
                        if (j < corsbBorderHorRaysPerRow && corsbAngle > 90)//primer 20% de rayos
                        {
                            auxAngle = 180 - corsbAngle;
                            corsbDistanceToBorder = (float)j * (float)horizontalRaySpacing;
                            //print("CONTROLLER 3D: CORSB system checking started (Part1)-> j = " + j + "; corsbDistanceToBorder = " + corsbDistanceToBorder);
                        }
                        else //último 20%
                        {
                            auxAngle = corsbAngle;
                            corsbDistanceToBorder = (float)(horizontalRaysPerRow - (j + 1)) * (float)horizontalRaySpacing;
                            //print("CONTROLLER 3D: CORSB system checking started (Part2)-> j = " + j + "; corsbDistanceToBorder = " + corsbDistanceToBorder);
                        }
                        auxCorsbSkinWidth = corsbDistanceToBorder / Mathf.Cos(auxAngle * Mathf.Deg2Rad);
                        //print("CONTROLLER 3D: CORSB system checking: i = " + i + "; j = " + j + "; corsbAngle = " + corsbAngle +
                        //    "; skinWidth = " + skinWidth + "; auxCorsbSkinWidth = " + auxCorsbSkinWidth + "; corsbDistanceToBorder = " +
                        //    corsbDistanceToBorder + "; Mathf.Cos(auxAngle * Mathf.Deg2Rad) = " + Mathf.Cos(auxAngle * Mathf.Deg2Rad));
                        if (auxCorsbSkinWidth < skinWidth)
                        {
                            corsbSkinWidth = auxCorsbSkinWidth;
                            corsbRayLength = rayLength - (skinWidth - auxCorsbSkinWidth);
                            //print("CONTROLLER 3D: CORSB system activated!");
                        }
                    }
                    // --- CORSB SYSTEM END ---
                    #endregion

                    if (showHorizontalLimits && !disableAllRays)
                    {
                        Debug.DrawLine(lastOriginZ, rayOriginZ, Color.blue);
                    }
                    lastOriginZ = rayOriginZ;
                    rayOriginZ += (-horVel * corsbSkinWidth);
                    RaycastHit hit;
                    if (showHorizontalRays && !disableAllRays)
                    {
                        Debug.DrawRay(rayOriginZ, horVel * corsbRayLength, (corsbSkinWidth < skinWidth ? corsbColor : Color.red));
                    }

                    if (Physics.Raycast(rayOriginZ, horVel, out hit, corsbRayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = SignedRelativeAngle(Vector3.forward, hit.normal);// Vector3.Angle(hit.normal, Vector3.forward);
                        Raycast auxRay = new Raycast(hit, (hit.distance - corsbSkinWidth), vel, rayOriginZ, true, slopeAngle, wallAngle, Axis.Z,
                            i, j, horizontalRows, corsbSkinWidth);
                        //WE STORE ALL THE RAYCASTS INFO
                        collisions.horRaycastsZ[i, j] = auxRay;

                        bool newClosestRay = !(i == 0 && j == 0) ? IsCloserHorizontalRay(collisions.closestHorRaycast, auxRay) : true;
                        if (newClosestRay)
                        {
                            collisions.closestHorRaycast = auxRay;
                        }
                        //Closest climbing ray
                        SaveClosestHorizontalClimbingRay(auxRay);
                    }
                    else
                    {
                        //WE STORE ALL THE RAYCASTS INFO
                        Raycast auxRay = new Raycast(hit, (hit.distance - corsbSkinWidth), vel, rayOriginZ, false, 0, 0, Axis.Z, i, j, horizontalRows, corsbSkinWidth);
                        collisions.horRaycastsZ[i, j] = auxRay;
                    }
                }
            }
        }
        #endregion
        #endregion

        if (collisions.closestHorRaycast.hit)//si ha habido una collision horizontal
        {
            CollisionState value = CheckSlopeType(vel, collisions.closestHorRaycast);
            //CollisionState value = CheckSlopeType(ref vel, collisions.closestHorRaycast);

            if (value == CollisionState.wall)
            {
                #region --- SLOPE'S BORDER WALL PROBLEMATIC ---
                if (collisions.closestHorRaycastClimb.hit)
                {
                    bool success = false;
                    //Debug.LogWarning("Climbing slope and colliding with wall at the same time!: transform of wall = " + collisions.closestHorRaycast.ray.transform
                    //    + "; transform of slope = " + collisions.closestHorRaycastClimb.ray.transform);
                    if (collisions.closestHorRaycast.ray.transform == collisions.closestHorRaycastClimb.ray.transform)
                    {
                        success = true;
                    }
                    if (success)
                    {
                        collisions.closestHorRaycast = collisions.closestHorRaycastClimb;
                        value = CollisionState.climbing;
                    }
                }
                #endregion

                #region --- CHECK FOR CLIMBSTEP ---
                //check for climbStep
                float rayHeight = collisions.closestHorRaycast.row * horizontalRowSpacing;
                if (rayHeight <= maxHeightToClimbStep)
                {
                    //CHECK IF THE WALL IS SHORT
                    bool success = true;
                    Vector3 horVelAux = new Vector3(vel.x, 0, vel.z);
                    rayLength = (horVelAux.magnitude + collisions.closestHorRaycast.skinWidth);
                    Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;
                    RaycastHit hit;
                    if (!disableAllRays) Debug.DrawRay(rayOrigin, horVelAux * rayLength, Color.yellow, 4);

                    if (Physics.Raycast(rayOrigin, horVelAux, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {

                        //for(int i = collisions.closestHorRaycast.row+1; i< collisions.horRaycastsX.GetLength(0); i++)
                        //{
                        //    //check if there was a hit 
                        //}
                        if (success)
                        {
                            //value = CollisionState.climbStep;
                        }
                    }
                }
                #endregion
            }

            //print("COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                #region Wall
                case CollisionState.wall:
                    //Debug.LogWarning("WALL: START");
                    float auxRayLength = new Vector3(collisions.closestHorRaycast.vel.x, 0, collisions.closestHorRaycast.vel.z).magnitude;
                    if (!disableAllRays && showHorizontalRays) Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * (auxRayLength), Color.white);
                    #region -- Wall Edges --
                    WallEdges(vel);
                    #endregion

                    #region -- VALID WALL --
                    //check if the "wall" is not just the floor/really small ridge
                    bool validWall = false;
                    if (collisions.lastCollSt == CollisionState.descending)
                    {
                        float heightToPrecisionHeight = precisionHeight - (collisions.closestHorRaycast.origin.y - raycastOrigins.BottomLBCornerReal.y);
                        if (heightToPrecisionHeight <= 0)
                        {
                            validWall = true;
                        }
                        else
                        {
                            Vector3 rayOriginAux = collisions.closestHorRaycast.origin + Vector3.up * heightToPrecisionHeight;
                            RaycastHit hitAux;
                            if (Physics.Raycast(rayOriginAux, horVel, out hitAux, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                            {
                                float slopeAngle = GetSlopeAngle(hitAux);
                                if (slopeAngle == collisions.closestHorRaycast.slopeAngle)
                                {
                                    validWall = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        validWall = true;
                    }
                    #endregion
                    if (validWall)
                    {
                        float angleBetweenWalls = SignedRelativeAngle(collisions.oldWallNormal, collisions.closestHorRaycast.ray.normal);
                        int clockWise = 0;
                        if (angleBetweenWalls > 0)
                        {
                            clockWise = 1;
                        }
                        else if (angleBetweenWalls < 0)
                        {
                            clockWise = -1;
                        }
                        //                    Debug.LogWarning("WALL: old wall angle = " + collisions.wallAngleOld + "; new wall angle = " + collisions.closestHorRaycast.wallAngle +
                        //"; oldSlideSt = " + collisions.oldSlideSt+ "; clockWise = " + clockWise);
                        if (collisions.wallAngleOld == -500 || (AreAnglesDifferent(collisions.wallAngleOld, collisions.closestHorRaycast.wallAngle) &&
                            ((collisions.oldSlideSt == SlideState.right && clockWise == 1) || (collisions.oldSlideSt == SlideState.left && clockWise == -1))))//NEW WALL
                        {
                            Debug.LogError("WALL: APPROACHING NEW WALL: " + "distance = " + collisions.closestHorRaycast.distance);
                            if (collisions.closestHorRaycastClimb.hit)//CLIMBING AND FOUND A WALL
                            {
                                ClimbSlope(ref vel, collisions.closestHorRaycastClimb);
                                horVel = new Vector3(vel.x, 0, vel.z).normalized;
                                horVel = horVel * (collisions.closestHorRaycast.distance);
                                vel = new Vector3(horVel.x, vel.y, horVel.z);
                                float y = Mathf.Tan(collisions.realSlopeAngle * Mathf.Deg2Rad) * horVel.magnitude;
                                vel.y = y;
                                Debug.LogError("Found a wall while climbing. vel = " + vel.ToString("F6") + "; slopeAngle = " + collisions.slopeAngle + "; realSlopeAngle = " + collisions.realSlopeAngle);
                            }
                            else
                            {
                                horVel = horVel * (collisions.closestHorRaycast.distance);
                                vel = new Vector3(horVel.x, vel.y, horVel.z);
                            }
                            collisions.wallAngle = collisions.closestHorRaycast.wallAngle;
                        }
                        else//COLLIDING WITH WALL and not the first frame (stop frame, the frame we use to stop in time before going through the wall)
                        {
                            if (collisions.closestHorRaycast.distance < 0)//SI ESTAMOS METIDOS DENTRO DEL MURO POR ALGUN MOTIVO
                            {
                                Vector3 moveOutVel = horVel.normalized * collisions.closestHorRaycast.distance;
                                transform.Translate(moveOutVel, Space.World);
                            }
                            //Debug.LogWarning("WALL SLIDE: START");
                            WallSlide(ref vel, collisions.closestHorRaycast);
                            //GUARDAMOS PARÁMETROS DE COLLISIONS
                            collisions.horCollisionsPoint = collisions.closestHorRaycast.ray.point;
                            collisions.wallNormal = collisions.closestHorRaycast.ray.normal;
                            collisions.horWall = collisions.closestHorRaycast.ray.transform.gameObject;
                            switch (collisions.closestHorRaycast.axis)
                            {
                                case Axis.X:
                                    collisions.left = directionX == -1;
                                    collisions.right = directionX == 1;
                                    break;
                                case Axis.Z:
                                    collisions.behind = directionZ == -1;
                                    collisions.foward = directionZ == 1;
                                    break;
                            }
                            //TO TEST: Esto debería ser en un rayo a la altura de los pies(done)
                            RaycastHit hitAux;
                            Vector3 origin = collisions.closestHorRaycast.origin;
                            origin.y = collisions.horRaycastsX[0, 0].origin.y;
                            if (Physics.Raycast(origin, Vector3.down, out hitAux, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                            {
                                collisions.floorAngle = GetSlopeAngle(hitAux);
                            }
                            WallSlideCollisions(ref vel);
                        }
                    }
                    break;
                #endregion
                #region Climbing
                case CollisionState.climbing:
                    //Debug.Log("Start climbing = " + vel.ToString("F4") + "; CollisionState = " + collisions.collSt + "; below = " + collisions.below);
                    //print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                    #region error check
                    if (collisions.closestHorRaycast.row > 0)//THIS IS FOR ERROR CHECKING
                    {
                        Debug.LogError("collided with a ray that is row " + collisions.closestHorRaycast.row + "; Axis = " + collisions.closestHorRaycast.axis);
                        for (int i = 0; i <= collisions.closestHorRaycast.row; i++)
                        {
                            string message = "Line " + i + " has distances:[";
                            for (int j = 0; j < collisions.horRaycastsZ.GetLength(1); j++)
                            {
                                message += collisions.horRaycastsZ[i, j].distance.ToString("F6") + ",";
                            }
                            message += "]";
                            print(message);
                        }
                    }
                    #endregion
                    if (!disableAllRays) Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * rayLength, Color.cyan, 4);

                    float distanceToSlopeStart = 0;
                    if (collisions.slopeAngleOld != collisions.closestHorRaycast.slopeAngle)
                    {
                        distanceToSlopeStart = collisions.closestHorRaycast.distance;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    Debug.Log("Start ClimbSlope = " + vel.ToString("F4") + "; CollisionState = " + collisions.collSt + "; below = " + collisions.below);
                    ClimbSlope(ref vel, collisions.closestHorRaycast);
                    Debug.Log("Finish ClimbSlope = " + vel.ToString("F4") + "; CollisionState = " + collisions.collSt + "; below = " + collisions.below);
                    horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);
                    Debug.Log("After ClimbSlope = " + vel.ToString("F4") + "; CollisionState = " + collisions.collSt + "; below = " + collisions.below);
                    //--------------------- CHECK FOR NEXT SLOPE -------------------------------------
                    //TO DO: NEW SLOPE CHECK MUST BE DONE BY THROWING every ray possible in line i=0, not by throwing 1 ray only. 
                    Vector3 horVelAux = new Vector3(vel.x, 0, vel.z);
                    rayLength = (horVelAux.magnitude + collisions.closestHorRaycast.skinWidth);
                    Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;
                    RaycastHit hit;
                    if (!disableAllRays) Debug.DrawRay(rayOrigin, horVelAux * rayLength, Color.yellow, 4);

                    if (Physics.Raycast(rayOrigin, horVelAux, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        if (!disableAllRays) Debug.DrawRay(rayOrigin, horVelAux * rayLength, Color.magenta, 4);

                        if (slopeAngle != collisions.slopeAngle)//NEW SLOPE FOUND
                        {
                            horVelAux = horVelAux.normalized * (hit.distance - collisions.closestHorRaycast.skinWidth);
                            float y = vel.y;
                            vel = new Vector3(horVelAux.x, y, horVelAux.z);
                            collisions.slopeAngle = slopeAngle;
                        }
                    }
                    else
                    {
                        //Debug.LogWarning("Climbing slope finished!");
                        collisions.finishedClimbing = true;
                    }
                    //Debug.Log("END climbing = " + vel.ToString("F4") + "; CollisionState = " + collisions.collSt + "; below = " + collisions.below);
                    break;
                #endregion
                #region ClimbStep
                case CollisionState.climbStep:
                    Debug.LogWarning("CLIMB STEP STARTED");
                    break;
                    #endregion
            }
        }
    }*/

//WALL EDGE

    //bool WallEdges(Vector3 vel, ref Raycast closestHorRaycast)
    //{
    //    //ONLY ENTER IF closesthorRatCast = wall;
    //    Raycast auxClosestRay = closestHorRaycast;
    //    bool success = false;
    //    Raycast differentWallRay = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
    //    Debug.LogWarning("WALL EDGE: START");

    //    #region --- Primera comprobacion (raycasts actuales) ---
    //    //for (int i = 0; i < collisions.horRaycastsX.GetLength(0); i++)
    //    //{
    //    //    for (int j = 0; j < collisions.horRaycastsX.GetLength(1); j++)
    //    //    {
    //    //        if (i == 0 && j == 0) Debug.LogWarning("WALL EDGE: PRIMERA COMPROBACION START");
    //    //        if (collisions.horRaycastsX[i, j].hit)
    //    //        {
    //    //            CollisionState slopeType = CheckSlopeTypeWallEdges(vel, collisions.horRaycastsX[i, j]);
    //    //            if (slopeType == CollisionState.wall && AreAnglesDifferent(collisions.horRaycastsX[i, j].wallAngle, closestHorRaycast.wallAngle) &&
    //    //                collisions.horRaycastsX[i, j].distance < differentWallRay.distance)
    //    //            {
    //    //                differentWallRay.distance = collisions.horRaycastsX[i, j].distance;
    //    //                differentWallRay = collisions.horRaycastsX[i, j];
    //    //            }
    //    //        }
    //    //        if (collisions.horRaycastsZ[i, j].hit)
    //    //        {
    //    //            CollisionState slopeType = CheckSlopeTypeWallEdges(vel, collisions.horRaycastsZ[i, j]);
    //    //            if (slopeType == CollisionState.wall && AreAnglesDifferent(collisions.horRaycastsZ[i, j].wallAngle, closestHorRaycast.wallAngle) &&
    //    //                collisions.horRaycastsZ[i, j].distance < differentWallRay.distance)
    //    //            {
    //    //                differentWallRay.distance = collisions.horRaycastsZ[i, j].distance;
    //    //                differentWallRay = collisions.horRaycastsZ[i, j];
    //    //            }
    //    //        }
    //    //    }
    //    //}
    //    #endregion

    //    #region --- Segunda comprobacion / HIGH PRECISION (lanzando nuevos raycasts) ---
    //    if (!differentWallRay.hit)
    //    {
    //        Debug.LogWarning("WALL EDGE: SEGUNDA COMPROBACION START");
    //        bool seikai = false;//seikai = correcto en japonés. es que quería usar "success" pero ya estaba usado
    //        int column = closestHorRaycast.column;
    //        int row = closestHorRaycast.row;
    //        Axis originalAxis = closestHorRaycast.axis;
    //        for (int sentido = -1; sentido < 2 && !seikai; sentido = sentido == -1 ? sentido = 1 : sentido = 2)//1=+;-1=- (en el orden de creación de rayos: BACK Y RIGHT ) 
    //        {
    //            float auxSkinWidth, raylength;
    //            Vector3 horVel, rayOrigin;
    //            Axis finalAxis = originalAxis;
    //            int finalSentido = sentido;
    //            bool throwRays = false;
    //            if (!((column == 0 && sentido == -1) || (column == (horizontalRaysPerRow - 1) && sentido == 1)))
    //            {
    //                throwRays = true;
    //                auxSkinWidth = originalAxis == Axis.X ?
    //                    collisions.horRaycastsX[row, column + sentido].skinWidth : collisions.horRaycastsZ[row, column + sentido].skinWidth;
    //                horVel = new Vector3(vel.x, 0, vel.z);// DO NOT CHANGE ORDER
    //                raylength = horVel.magnitude + auxSkinWidth;// DO NOT CHANGE ORDER
    //                horVel.Normalize();// DO NOT CHANGE ORDER
    //                rayOrigin = closestHorRaycast.origin + (horVel * closestHorRaycast.skinWidth);
    //            }
    //            #region Cambio de eje
    //            else//CAMBIO DE EJE
    //            {
    //                auxSkinWidth = closestHorRaycast.skinWidth;
    //                horVel = new Vector3(vel.x, 0, vel.z);// DO NOT CHANGE ORDER
    //                raylength = horVel.magnitude + auxSkinWidth;// DO NOT CHANGE ORDER
    //                horVel.Normalize();// DO NOT CHANGE ORDER
    //                rayOrigin = closestHorRaycast.origin + (horVel * closestHorRaycast.skinWidth);
    //                if (originalAxis == Axis.X)
    //                {
    //                    finalAxis = Axis.Z;
    //                    if (vel.x > 0)
    //                    {
    //                        if (column == 0 && vel.z > 0)//AL PRINCIPIO, en este caso es ARRIBA
    //                        {
    //                            throwRays = true;
    //                            column = horizontalRaysPerRow - 1;
    //                        }
    //                        else if (column == horizontalRaysPerRow - 1 && vel.z < 0)//AL FINAL, en este caso es ABAJO
    //                        {
    //                            throwRays = true;
    //                            finalSentido = -1;
    //                        }
    //                    }
    //                    else if (vel.x < 0)
    //                    {
    //                        if (column == 0 && vel.z > 0)//AL PRINCIPIO, en este caso es ARRIBA
    //                        {
    //                            throwRays = true;
    //                            finalSentido = 1;
    //                        }
    //                        else if (column == horizontalRaysPerRow - 1 && vel.z < 0)//AL FINAL, en este caso es ABAJO
    //                        {
    //                            throwRays = true;
    //                            column = 0;
    //                        }
    //                    }
    //                }
    //                else //EJE Z
    //                {
    //                    finalAxis = Axis.X;
    //                    if (vel.z > 0)
    //                    {
    //                        if (column == 0 && vel.x < 0) //AL PRINCIPIO, en este caso es a la IZDA
    //                        {
    //                            throwRays = true;
    //                            finalSentido = 1;
    //                        }
    //                        else if (column == horizontalRaysPerRow - 1 && vel.x > 0)//AL FINAL, en este caso es a la DCHA
    //                        {
    //                            throwRays = true;
    //                            column = 0;
    //                        }
    //                    }
    //                    else if (vel.z < 0)
    //                    {
    //                        if (column == 0 && vel.x < 0) //AL PRINCIPIO, en este caso es a la IZDA
    //                        {
    //                            throwRays = true;
    //                            column = horizontalRaysPerRow - 1;
    //                        }
    //                        else if (column == horizontalRaysPerRow - 1 && vel.x > 0)//AL FINAL, en este caso es a la DCHA
    //                        {
    //                            throwRays = true;
    //                            finalSentido = -1;
    //                        }
    //                    }

    //                }
    //            }
    //            #endregion
    //            for (int j = 1; j < wallEdgeHighPrecissionRays - 1 && !seikai && throwRays; j++)
    //            {
    //                Vector3 localRayOrigin = rayOrigin;
    //                localRayOrigin += finalAxis == Axis.X ?
    //                Vector3.back * finalSentido * wallEdgeHighPrecisionHorRaySpacing * j : Vector3.right * finalSentido * wallEdgeHighPrecisionHorRaySpacing * j;
    //                //Debug.Log("WALL EDGE: High Precision -> auxSkinWidth = " + auxSkinWidth.ToString("F6")+"; storedRaySkinWidth = "+ 
    //                //    (collisions.horRaycastsZ[row, column + sentido].skinWidth).ToString("F6"));
    //                localRayOrigin += (-horVel * auxSkinWidth);
    //                //lanzar raycast
    //                RaycastHit hit;
    //                if (showWallEdgeRays && !disableAllRays)
    //                {
    //                    Debug.DrawRay(localRayOrigin, horVel * raylength, purple);
    //                }
    //                if (Physics.Raycast(localRayOrigin, horVel, out hit, raylength, collisionMask, QueryTriggerInteraction.Ignore))
    //                {
    //                    float slopeAngle = GetSlopeAngle(hit);
    //                    float wallAngle = SignedRelativeAngle(Vector3.forward, hit.normal, Vector3.up); //Vector3.Angle(hit.normal, Vector3.forward);
    //                    Raycast auxRay = new Raycast(hit, (hit.distance - auxSkinWidth), vel, localRayOrigin, true, slopeAngle, wallAngle,
    //                        originalAxis, row, column, horizontalRows, auxSkinWidth);
    //                    CollisionState slopeType = CheckSlopeTypeWallEdges(vel, auxRay);
    //                    if (slopeType == CollisionState.wall && AreAnglesDifferent(auxRay.wallAngle, closestHorRaycast.wallAngle))
    //                    {
    //                        //Debug.LogWarning("WALL EDGE: SEGUNDA COMPROBACION -> found!");
    //                        differentWallRay = auxRay;
    //                        if (differentWallRay.distance < auxClosestRay.distance) auxClosestRay = differentWallRay;
    //                        seikai = true;
    //                    }
    //                }
    //            }
    //            //sentido = sentido == -1 ? sentido = 1 : sentido = 2;//at the end
    //        }
    //    }
    //    //else// rellenar de forma que se tiren rayos de precisión entre  los dos rayos encontrados en la comprobación 1
    //    //{

    //    //}
    //    #endregion

    //    if (differentWallRay.hit)//DOS TIPOS DE MURO ENCONTRADOS
    //    {
    //        #region --- Comprobar si convexo o cóncavo ---
    //        Debug.LogWarning("WALL EDGE: COMPROBACION CONCAVO/CONVEXO START");
    //        Debug.Log("WALL EDGE: Rayo 1 -> (" + closestHorRaycast.row + "," + closestHorRaycast.column + "), wallAngle = " + closestHorRaycast.wallAngle +
    //            "; Rayo 2 -> (" + differentWallRay.row + "," + differentWallRay.column + "), wallAngle = " + differentWallRay.wallAngle);
    //        // --- Comprobar que forman un ángulo convexo ---
    //        // -- Para ello primero comprobamos cual de los dos puntos es el del muro de nuestra izda y cual el de la dcha -- 
    //        // the vector that we want to measure an angle from
    //        Vector3 referenceForward = closestHorRaycast.ray.point - closestHorRaycast.origin;/* some vector that is not Vector3.up */
    //        referenceForward.y = 0; referenceForward.Normalize();
    //        // the vector of interest 
    //        //Vector3 vector1 = closestHorRaycast.ray.point - coll.bounds.center;// some vector that we're interested in 
    //        Vector3 vector2 = differentWallRay.ray.point - closestHorRaycast.origin;// some vector that we're interested in 
    //                                                                                //vector1.y = vector2.y = 0;vector1 = vector1.normalized; vector2 = vector2.normalized;
    //        vector2.y = 0; vector2 = vector2.normalized;
    //        if (!disableAllRays && showWallEdgeRays)
    //        {
    //            Debug.DrawRay(closestHorRaycast.origin, referenceForward * 1f, Color.yellow);
    //            Debug.DrawRay(closestHorRaycast.origin, vector2 * 1f, Color.black);
    //        }

    //        //float angle1 = SignedRelativeAngle(referenceForward, vector1);
    //        float angle2 = SignedRelativeAngle(referenceForward, vector2, Vector3.up);
    //        bool angle1IsRight = (angle2 < 0);
    //        Vector3 wallVectorDcha;
    //        Vector3 wallVectorIzda;
    //        if (angle1IsRight)
    //        {
    //            wallVectorDcha = new Vector3(-closestHorRaycast.ray.normal.z, 0, closestHorRaycast.ray.normal.x).normalized;
    //            wallVectorIzda = new Vector3(differentWallRay.ray.normal.z, 0, -differentWallRay.ray.normal.x).normalized;
    //        }
    //        else
    //        {
    //            wallVectorIzda = new Vector3(closestHorRaycast.ray.normal.z, 0, -closestHorRaycast.ray.normal.x).normalized;
    //            wallVectorDcha = new Vector3(-differentWallRay.ray.normal.z, 0, differentWallRay.ray.normal.x).normalized;
    //        }
    //        if (!disableAllRays && showWallEdgeRays)
    //        {
    //            Debug.DrawRay(differentWallRay.ray.point, wallVectorIzda * 2, angle1IsRight ? Color.magenta : Color.black);
    //            Debug.DrawRay(closestHorRaycast.ray.point, wallVectorDcha * 2, angle1IsRight ? Color.black : Color.magenta);
    //        }
    //        //Debug.LogWarning("WALL EDGE: collPoint1 = " + closestHorRaycast.ray.point.ToString("F4") + "; collPoint2 = " + differentWallRay.ray.point.ToString("F4") +
    //        //    "; vector2 = " + vector2 + "; angle2 = " + angle2 + "; angle1IsRight = " + angle1IsRight);

    //        float cornerAngle = SignedRelativeAngle(wallVectorIzda, wallVectorDcha, Vector3.up);
    //        //Debug.LogWarning("WALL EDGE: COMPROBACION CONCAVO/CONVEXO -> cornerAngle = "+ cornerAngle);
    //        #endregion

    //        if (cornerAngle >= 0 && Mathf.Abs(cornerAngle) != 180)// -- ES UNA ESQUINA CONVEXA -- 
    //        {
    //            #region --- Crear el plano ---
    //            Debug.LogWarning("WALL EDGE: Estamos en una esquina convexa!");
    //            // --- CREAR EL PLANO --- 
    //            //crear un plano teniendo en cuenta que ángulo A + B + A = 180º
    //            //como en este dibujo:           \  B /   
    //            //                        Muro 1->\  /<-Muro 2
    //            //                              A (\/) A    <- Pico de un muro
    //            //                        --------------------- Plano

    //            //float sideAngle = (180 - cornerAngle) / 2;
    //            Vector3 planeNormal = -(wallVectorIzda + wallVectorDcha);
    //            Plane imaginaryWall = new Plane(planeNormal, auxClosestRay.ray.point);
    //            if (showWallEdgeRays && !disableAllRays)
    //            {
    //                DrawPlane(auxClosestRay.ray.point, planeNormal, Color.green);
    //            }
    //            #endregion

    //            #region --- Raycast colisionando con ese plano ---
    //            // --- RAYCAST COLISIONANDO CON ESE PLANO --- 
    //            float enter = 0.0f;
    //            Vector3 horVel = new Vector3(vel.x, 0, vel.z);
    //            float auxSkinWidth = auxClosestRay.skinWidth;
    //            float raylength = horVel.magnitude + auxSkinWidth;
    //            Vector3 origin = auxClosestRay.origin;
    //            Ray ray = new Ray(origin, horVel.normalized * raylength);
    //            if (imaginaryWall.Raycast(ray, out enter))
    //            {
    //                float slopeAngle = GetSlopeAngle(planeNormal);
    //                float wallAngle = SignedRelativeAngle(Vector3.forward, planeNormal, Vector3.up); ; Vector3.Angle(planeNormal, Vector3.forward);
    //                float distance = (ray.GetPoint(enter) - origin).magnitude - auxSkinWidth;
    //                auxClosestRay.ray.normal = planeNormal;
    //                auxClosestRay.ray.point = ray.GetPoint(enter);
    //                Debug.LogWarning("WALL EDGE: We hit the imaginary wall: enter = " + enter + "; ray dir = " + horVel + "; raylength = " + raylength
    //+ "; origin = " + origin + "; slopeAngle = " + slopeAngle + "; oldSlopeAngle = " + auxClosestRay.slopeAngle
    //+ "; wallAngle = " + wallAngle + "; oldWallAngle = " + auxClosestRay.wallAngle + "; distance = " + distance
    //+ "; oldDistance = " + auxClosestRay.distance);
    //                closestHorRaycast = new Raycast(auxClosestRay.ray, distance, vel, origin, true, slopeAngle, wallAngle,
    //                    auxClosestRay.axis, auxClosestRay.row, auxClosestRay.column, horizontalRows, auxSkinWidth);
    //                success = true;
    //            }
    //            else
    //            {
    //                Debug.LogError("Error: Wall edge is trying to collide with the plane we just calculated, but there was no collision.");
    //            }
    //            #endregion
    //        }
    //    }
    //    return success;
    //}


	#region wallVectors method (deprecated)
            //Debug.Log("WALL EDGE ALL: closestHorRaycast -> (" + closestHorRaycast.row + "," + closestHorRaycast.column + "), wallAngle = " + closestHorRaycast.wallAngle +
            //    "; differentWallRay -> (" + differentWallRay.row + "," + differentWallRay.column + "), wallAngle = " + differentWallRay.wallAngle);

            // --- Comprobar que forman un ángulo convexo ---
            // -- Para ello primero comprobamos cual de los dos puntos es el del muro de nuestra izda y cual el de la dcha -- 
            // the vector that we want to measure an angle from
            //Vector3 referenceForward = (closestHorRaycast.ray.point - closestHorRaycast.origin).normalized;/* some vector that is not Vector3.up */
            ////referenceForward.y = 0;//TO TEST: I don't know if this is needed
            //// the vector of interest 
            //Vector3 vector2 = (differentWallRay.ray.point - closestHorRaycast.origin).normalized;/* some vector that we're interested in */
            //                                                                                     //vector1.y = vector2.y = 0;vector1 = vector1.normalized; vector2 = vector2.normalized;
            //                                                                                     //vector2.y = 0;
            //if (!disableAllRays && showWallEdgeRays)
            //{
            //    Debug.DrawRay(closestHorRaycast.origin, referenceForward * 1f, Color.yellow);
            //    Debug.DrawRay(closestHorRaycast.origin, vector2 * 1f, Color.black);
            //}
            //Debug.Log("FOUND = " + found);

            //Vector3 wallVectorDcha;
            //Vector3 wallVectorIzda;
            //if (closestRayIsRight)
            //{
            //    wallVectorDcha = new Vector3(-closestHorRaycast.ray.normal.z, 0, closestHorRaycast.ray.normal.x).normalized;
            //    wallVectorIzda = new Vector3(differentWallRay.ray.normal.z, 0, -differentWallRay.ray.normal.x).normalized;
            //}
            //else
            //{
            //    wallVectorIzda = new Vector3(closestHorRaycast.ray.normal.z, 0, -closestHorRaycast.ray.normal.x).normalized;
            //    wallVectorDcha = new Vector3(-differentWallRay.ray.normal.z, 0, differentWallRay.ray.normal.x).normalized;
            //}
            //if (!disableAllRays && showWallEdgeRays)
            //{
            //    Debug.DrawRay(differentWallRay.ray.point, wallVectorIzda * 2, closestRayIsRight ? Color.magenta : Color.black);
            //    Debug.DrawRay(closestHorRaycast.ray.point, wallVectorDcha * 2, closestRayIsRight ? Color.black : Color.magenta);
            //}
            ////Debug.LogWarning("WALL EDGE: collPoint1 = " + closestHorRaycast.ray.point.ToString("F4") + "; collPoint2 = " + differentWallRay.ray.point.ToString("F4") +
            ////    "; vector2 = " + vector2 + "; angle2 = " + angle2 + "; angle1IsRight = " + angle1IsRight);

            //float cornerAngle = SignedRelativeAngle(wallVectorIzda, wallVectorDcha, Vector3.up);
            #endregion


			//PERFECT EDGE COLLISION

			                    //float backDistance = 0;//distance we must go back in the auxClosestRay to stop hitting the wall edge.
                    //bool hasHit = true;
                    //Vector3 rayOrigin = auxClosestRay.ray.point;
                    //Vector3 auxHorVel = new Vector3(vel.x, 0, vel.z);
                    //Vector3 rayEnd = auxOtherRay.ray.point;

                    ////Debug.LogWarning("WALL EDGE ALL: CHECK FOR PERFECT EDGE COLLISION POINT  -> rayOrigin = " + rayOrigin.ToString("F4") + "; rayEnd = " + rayEnd.ToString("F4"));
                    //for (int k = 1; k < 50 && hasHit; k++)
                    //{
                    //    Vector3 localRayOrigin = rayOrigin - auxHorVel * (k * wallEdgeHighCheckForPerfectEdgeRaySpacing);
                    //    Vector3 localRayEnd = rayEnd - auxHorVel * (k * wallEdgeHighCheckForPerfectEdgeRaySpacing);
                    //    if (showWallEdgeRays && !disableAllRays) Debug.DrawLine(localRayOrigin, localRayEnd, Color.red);

                    //    if (!Physics.Linecast(localRayOrigin, localRayEnd, collisionMask, QueryTriggerInteraction.Ignore))
                    //    {
                    //        //Debug.LogWarning("WALL EDGE ALL: CHECK FOR PERFECT EDGE COLLISION POINT  ->  NO HIT -> distance found!");
                    //        backDistance = k * wallEdgeHighCheckForPerfectEdgeRaySpacing;
                    //        hasHit = false;
                    //    }
                    //}
                    //float diffBetweenBackDistAndDist = Mathf.Abs(auxClosestRay.distance - backDistance);
                    ////if (!disableAllDebugs) Debug.Log("WALL EDGE ALL: diffBetweenBackDistAndDist = " + diffBetweenBackDistAndDist + "; auxClosestRay.distance = " + auxClosestRay.distance + "; backDistance = " + backDistance);
                    //Vector3 imaginaryWallPoint = auxClosestRay.ray.point - (auxHorVel *
                    //    (diffBetweenBackDistAndDist < wallEdgeHighCheckForPerfectEdgeRaySpacing ? auxClosestRay.distance : backDistance));
                    ////Debug.Log("WALL EDGE ALL: CHECK IF WE ARE INSIDE WALL : backDistance = "+ backDistance + "; imaginaryWallPoint = "+ imaginaryWallPoint.ToString("F4") 
                    //    + "; auxClosestRay.ray.point = " + auxClosestRay.ray.point.ToString("F4"));