//PlayerMovement ProcessWallJump
{
            //CHECK IF WE ARE STILL ON THE WALL 
            //(since we are sliding off we will eventually have no more wall to hang from)

            /*if (lastWall == controller.collisions.horWall)
            {
                bool success = false;
                if (wallJumpRaycastAxis == Raycast.Axis.X)
                {
                    for (int i = 0; i < controller.collisions.horRaycastsX.GetLength(0) && !success; i++)
                    {
                        for (int j = 0; j < controller.collisions.horRaycastsX.GetLength(1) && !success; j++)
                        {
                            if (controller.collisions.horRaycastsX[i, j].axis == Raycast.Axis.X && controller.collisions.horRaycastsX[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                            {
                                success = true;
                                Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                            }
                        }
                    }
                }
                else if (wallJumpRaycastAxis == Raycast.Axis.Z)
                {
                    for (int i = 0; i < controller.collisions.horRaycastsZ.GetLength(0) && !success; i++)
                    {
                        for (int j = 0; j < controller.collisions.horRaycastsZ.GetLength(1) && !success; j++)
                        {
                            if (controller.collisions.horRaycastsZ[i, j].axis == Raycast.Axis.Z && controller.collisions.horRaycastsZ[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                            {
                                success = true;
                                Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                            }
                        }
                    }
                }
            }
            else if (lastWall == controller.collisions.verWall)
            {
                bool success = false;
                for (int i = 0; i < controller.collisions.verRaycastsY.GetLength(0) && !success; i++)
                {
                    for (int j = 0; j < controller.collisions.verRaycastsY.GetLength(1) && !success; j++)
                    {
                        if (controller.collisions.verRaycastsY[i, j].axis == Raycast.Axis.Y && controller.collisions.horRaycastsX[i, j].rayHeightPercentage <= wallJumpMinHeightPercent)
                        {
                            success = true;
                            Debug.Log("WallJump: There is still at least 1 raycast colliding with the wall and below " + wallJumpMinHeightPercent + "%");
                        }
                    }
                }
            }
            else
            {
                Debug.Log("WallJump: StopWallJump, this wall (hor:" + controller.collisions.horWall + "; ver: "+ controller.collisions.verWall + ")is not the same wall that I started walljumping from (" + lastWall + ").");
                StopWallJump();
            }*/
}



void VerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "CAPSULE" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 RowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 RowOrigin = RowsOrigin;
        //float radius = 0f;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            RowOrigin.z =RowsOrigin.z + (verticalRowSpacing*i);
            //radius = i * verticalRadiusSpacing;
            //print("i= " + i + "; Radius = " + radius);
            //circleOrigin = new Vector3(circleOrigin.x, circleOrigin.y, circleOrigin.z + (i * verticalRadiusSpacing));

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                float angle = (j * verticalRayAngleSpacing) * Mathf.Deg2Rad;
                float px = circleOrigin.x + radius * Mathf.Cos(angle);
                float pz = circleOrigin.z + radius * Mathf.Sin(angle);
                Vector3 rayOrigin = new Vector3(px + vel.x, circleOrigin.y, pz + vel.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt != ClimbingState.descending || slopeAngle > maxDescendAngle)
                    {
                        //print("VERTICAL COLLISIONS");
                    vel.y = (hit.distance - skinWidth) * directionY;
                    rayLength = hit.distance;

                    if (collisions.moveSt == ClimbingState.climbing)
                    {
                        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    collisions.below = directionY == -1;
                    collisions.above = directionY == 1;
                    }
                }
            }
            if (collisions.climbSt == ClimbingState.climbing && collisions.slopeAngle != collisions.slopeAngleOld)//new slope, being on a slope already.This avoids going into the slope b4 adapting to new slope.
            {
                Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                rayLength = horVel.magnitude + skinWidth;
                Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;//NEEDS TO BE FIXED, the real ray origin should be  = BottomCenter + horVel.normalized * radius - skinWidth;
                RaycastHit hit;
                if (Physics.Raycast(rayOrigin, horVel.normalized, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                    if (slopeAngle != collisions.slopeAngle)
                    {
                        Vector3 newHorVel = (hit.distance - skinWidth) * horVel.normalized;
                        collisions.slopeAngle = slopeAngle;
                    }
                }
            }
        }
    }
	
	
    void NewHorizontalCollisions(ref Vector3 vel)
    {
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            float slopeAngle = GetSlopeAngle(hit);
                            float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }

                    }
                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            float slopeAngle = GetSlopeAngle(hit);
                            float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                    }
                }
            }
        }

        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = collisions.closestHorRaycast.row == 0 ? CheckSlopeType(ref vel, collisions.closestHorRaycast) : MovingState.wall;
            print("COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                case MovingState.wall:
                    //horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                    //vel = new Vector3(horVel.x, vel.y, horVel.z);

                    //float distanceToWall = 0;
                    if (collisions.wallAngleOld != collisions.closestHorRaycast.wallAngle)
                    {
                        print("APPROACHING WALL: " + "distance = " + collisions.closestHorRaycast.distance);
                        horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        collisions.wallAngle = collisions.closestHorRaycast.wallAngle;
                        /*distanceToWall = collisions.closestHorRaycast.distance - skinWidth;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToWall);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);*/
                    }
                    else
                    {
                        SlideWall(ref vel, collisions.closestHorRaycast);
                    }
                    /*horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToWall);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);*/

                    if (collisions.lastmoveSt == MovingState.climbing)
                    {
                        collisions.moveSt = MovingState.climbing;
                        vel.y = Mathf.Tan(collisions.slopeAngleOld * Mathf.Deg2Rad) * horVel.magnitude;
                    }
                    switch (collisions.closestHorRaycast.axis)
                    {
                        case Raycast.Axis.X:
                            collisions.left = directionX == -1;
                            collisions.right = directionX == 1;
                            break;
                        case Raycast.Axis.Z:
                            collisions.behind = directionZ == -1;
                            collisions.foward = directionZ == 1;
                            break;
                    }
                    break;
                case MovingState.climbing:
                    Raycast hit = MovingDirHorizontalCollisions(ref vel);
                    if (hit.axis != Raycast.Axis.none)//Physics.Raycast(collisions.closestHorRaycast.origin, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                        Debug.DrawRay(hit.origin, horVel * rayLength, Color.cyan, 4);
                        float distanceToSlopeStart = 0;
                        if (collisions.slopeAngleOld != collisions.closestHorRaycast.slopeAngle)
                        {
                            //RaycastHit hit;
                            //Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * rayLength, Color.white);
                            distanceToSlopeStart = hit.distance - skinWidth;
                            horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        ClimbSlope(ref vel, collisions.closestHorRaycast);
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    else
                    {
                        Debug.LogWarning("COULDNT HIT SLOPE to check for distance");
                    }
                    break;
                case MovingState.descending:
                    break;
                case MovingState.none:
                    break;
            }
        }
    }
	
	    Raycast MovingDirHorizontalCollisions(ref Vector3 vel)
    {
        Raycast result = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                RaycastHit hit;
                Debug.DrawRay(rayOriginX, horVel * rayLength, Color.red,1);

                if (Physics.Raycast(rayOriginX, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, 0);
                    }


                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                RaycastHit hit;
                Debug.DrawRay(rayOriginZ, horVel * rayLength, Color.red,1);

                if (Physics.Raycast(rayOriginZ, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, 0);
                    }

                }
            }
        }
        MovingState value = CheckSlopeType(ref vel, result);
        if (value == MovingState.climbing)
        {
            return result;
        }
        else
        {
            return new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        }

    }
	    void NewHorizontalCollisions(ref Vector3 vel)
    {
        Raycast wallRay = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowsOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginX = rowsOriginX;
                rowOriginX.y = (rowsOriginX.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }
                        if (slopeAngle > maxClimbAngle && hit.distance < wallRay.distance)
                        {
                            wallRay = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, i);
                        }

                    }
                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowsOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int i = 0; i < horizontalRows; i++)
            {
                Vector3 rowOriginZ = rowsOriginZ;
                rowOriginZ.y = (rowsOriginZ.y) + i * horizontalRowSpacing;
                for (int j = 0; j < horizontalRaysPerRow; j++)
                {
                    Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                    RaycastHit hit;
                    Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLength, Color.red);

                    if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        if (hit.distance < collisions.closestHorRaycast.distance)
                        {
                            collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                        if (slopeAngle > maxClimbAngle && hit.distance < wallRay.distance)
                        {
                            wallRay = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, i);
                        }
                    }
                }
            }
        }

        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = collisions.closestHorRaycast.row == 0 ? CheckSlopeType(ref vel, collisions.closestHorRaycast) : MovingState.wall;
            print("COLLISION HOR: " + value + "; slopeAngle=" + collisions.closestHorRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? pared/cuesta arriba/cuesta abajo
            {
                case MovingState.wall:
                    //horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                    //vel = new Vector3(horVel.x, vel.y, horVel.z);

                    //float distanceToWall = 0;
                    if (collisions.wallAngleOld != collisions.closestHorRaycast.wallAngle)
                    {
                        print("APPROACHING WALL: " + "distance = " + collisions.closestHorRaycast.distance);
                        horVel = horVel * (collisions.closestHorRaycast.distance - skinWidth);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        collisions.wallAngle = collisions.closestHorRaycast.wallAngle;
                        /*distanceToWall = collisions.closestHorRaycast.distance - skinWidth;
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude - distanceToWall);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);*/
                    }
                    else
                    {
                        WallSlide(ref vel, collisions.closestHorRaycast,false);
                    }
                    /*horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude + distanceToWall);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);*/

                    /*if (collisions.lastMoveSt == MovingState.climbing)
                    {
                        collisions.moveSt = MovingState.climbing;
                        vel.y = Mathf.Tan(collisions.slopeAngleOld * Mathf.Deg2Rad) * horVel.magnitude;
                    }*/
                    switch (collisions.closestHorRaycast.axis)
                    {
                        case Raycast.Axis.X:
                            collisions.left = directionX == -1;
                            collisions.right = directionX == 1;
                            break;
                        case Raycast.Axis.Z:
                            collisions.behind = directionZ == -1;
                            collisions.foward = directionZ == 1;
                            break;
                    }
                    break;
                case MovingState.climbing:
                    Raycast hit = MovingDirHorizontalCollisions(ref vel);
                    if (hit.axis != Raycast.Axis.none)//Physics.Raycast(collisions.closestHorRaycast.origin, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        print("AUXILIAR RAYS FOR DISTANCE CALCULATION");
                        Debug.DrawRay(hit.origin, horVel * rayLength, Color.cyan, 4);
                        float distanceToSlopeStart = 0;
                        if (collisions.slopeAngleOld != collisions.closestHorRaycast.slopeAngle)
                        {
                            //RaycastHit hit;
                            //Debug.DrawRay(collisions.closestHorRaycast.origin, horVel * rayLength, Color.white);
                            distanceToSlopeStart = hit.distance - skinWidth;
                            horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        ClimbSlope(ref vel, collisions.closestHorRaycast);
                        horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                        if (wallRay.axis != Raycast.Axis.none)
                        {

                        }
                    }
                    else
                    {
                        Debug.LogWarning("COULDNT HIT SLOPE to check for distance");
                    }
                    break;
                case MovingState.descending:
                    break;
                case MovingState.none:
                    break;
            }
        }
    }//No se usa

    void NewVerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "Cube" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 rowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j), rowOrigin.y, rowOrigin.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    //print("Vertical Hit");
                    if (hit.distance < collisions.closestVerRaycast.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        collisions.closestVerRaycast = new Raycast(hit, hit.distance, vel, rayOrigin, slopeAngle, wallAngle, Raycast.Axis.Y, i);
                    }
                }
            }
        }
        if (collisions.closestVerRaycast.axis != Raycast.Axis.none)//si ha habido una collision horizontal
        {
            MovingState value = CheckSlopeType(ref vel, collisions.closestVerRaycast);
            //print("COLLISION VER: " + value + "; slopeAngle=" + collisions.closestVerRaycast.slopeAngle);
            if (value == MovingState.climbing)
            {
                value = MovingState.none;
            }
            //print("COLLISION " + value + "; slopeAngle=" + collisions.closestVerRaycast.slopeAngle);
            switch (value)//con que tipo de objeto collisionamos? suelo/cuesta arriba/cuesta abajo
            {
                case MovingState.none:
                    vel.y = (collisions.closestVerRaycast.distance - skinWidth) * directionY;
                    rayLength = collisions.closestVerRaycast.distance;
                    if (collisions.moveSt == MovingState.climbing)//Subiendo chocamos con un techo
                    {
                        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                        horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                        vel = new Vector3(horVel.x, vel.y, horVel.z);
                    }
                    collisions.below = directionY == -1;
                    collisions.above = directionY == 1;
                    break;
                case MovingState.climbing:
                    break;
                case MovingState.descending:
                    if (collisions.moveSt != MovingState.climbing)
                    {
                        float distanceToSlopeStart = 0;
                        //print("NEW SLOPE DESCENDING slope angle= " + collisions.closestVerRaycast.slopeAngle + "; hit point =" + collisions.closestVerRaycast.ray.point.ToString("F4"));
                        distanceToSlopeStart = collisions.closestVerRaycast.distance - skinWidth;
                        vel.y -= distanceToSlopeStart * -1;
                        print("DESCEND SLOPE");
                        DescendSlope(ref vel, collisions.closestVerRaycast);
                        vel.y += distanceToSlopeStart * -1;
                    }
                    //--------------------- CHECK FOR NEXT SLOPE/FLOOR -------------------------------------
                    Vector3 horVelAux = new Vector3(vel.x, 0, vel.z);
                    rayLength = (Mathf.Abs(vel.y) + skinWidth);
                    Vector3 rayOrigin = collisions.closestVerRaycast.origin + horVelAux;
                    RaycastHit hit;
                    Debug.DrawRay(rayOrigin, Vector3.down * rayLength, Color.yellow, 4);
                    if (Physics.Raycast(rayOrigin, Vector3.down, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        //+print("HIT  with angle = " + slopeAngle);
                        Debug.DrawRay(rayOrigin, Vector3.down * rayLength, Color.magenta, 4);
                        if (slopeAngle != collisions.slopeAngle)
                        {
                            //print("HIT NEW SLOPE/FLOOR with angle = " + slopeAngle);
                            vel.y = -(hit.distance - skinWidth);
                            //vel = new Vector3(horVelAux.x, vel.y, horVelAux.z);
                            collisions.slopeAngle = slopeAngle;
                        }
                    }
                    break;
            }
        }
    }//No se usa

    Raycast MovingDirHorizontalCollisions(ref Vector3 vel)
    {
        Raycast result = new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        horVel = horVel.normalized;
        float directionX = 0, directionZ = 0; ;

        if (vel.x != 0)
        {
            directionX = Mathf.Sign(vel.x);
            Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
                rayOriginX += (Vector3.right * directionX * skinWidth);
                rayOriginX += (-horVel * skinWidth);
                RaycastHit hit;
                Debug.DrawRay(rayOriginX, horVel * rayLength, Color.yellow, 0.1f);

                if (Physics.Raycast(rayOriginX, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X, 0);
                    }


                }
            }
        }

        if (vel.z != 0)
        {
            directionZ = Mathf.Sign(vel.z);
            Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
                rayOriginZ += (Vector3.forward * directionZ * skinWidth);
                rayOriginZ += (-horVel * skinWidth);
                RaycastHit hit;
                Debug.DrawRay(rayOriginZ, horVel * rayLength, Color.yellow, 0.1f);

                if (Physics.Raycast(rayOriginZ, horVel, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    if (hit.distance < result.distance)
                    {
                        float slopeAngle = GetSlopeAngle(hit);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        result = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z, 0);
                    }

                }
            }
        }
        MovingState val = CheckSlopeType(ref vel, result);
        if (val == MovingState.climbing)
        {
            return result;
        }
        else
        {
            return new Raycast(new RaycastHit(), float.MaxValue, Vector3.zero, Vector3.zero);
        }

    }//No se usa

    void HorizontalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D CAPSULE -------------------
        float directionX = Mathf.Sign(vel.x);
        float directionZ = Mathf.Sign(vel.z);

        Vector3 dirXZ = new Vector3(vel.x, 0, vel.z);
        //PERPENDICULAR VECTOR TO MOVING DIR
        float perpX = 1;
        float perpZ = (-dirXZ.x / dirXZ.z) * perpX;
        Vector3 perpVector = new Vector3(perpX, 0, perpZ).normalized;
        Vector3 rowDir = -perpVector;

        float rayLength = Mathf.Abs(dirXZ.magnitude) + skinWidth;
        //CIRCUMFERENCE POINT THAT INTERSECTS WITH dirXZ THAT CROSSES CENTER
        Vector3 rowsOriginCenter = dirXZ.normalized * (horizontalRadius - skinWidth);
        float rx = rowsOriginCenter.x + raycastOrigins.BottomCenterH.x;
        float rz = rowsOriginCenter.z + raycastOrigins.BottomCenterH.z;
        rowsOriginCenter = new Vector3(rx, raycastOrigins.BottomCenterH.y, rz);
        //CIRCUMFERENCE POINT THAT INTERSECTS WITH PERPENDICULAR VECTOR THAT CROSSES CENTER
        /*float angle = Mathf.Acos(((1 * perpVector.x) + (0 * perpVector.z)) / (1 * perpVector.magnitude)) * Mathf.Rad2Deg;
        float px = raycastOrigins.BottomCenter.x + horizontalRadius * Mathf.Cos(angle);
        float pz = raycastOrigins.BottomCenter.z + horizontalRadius * Mathf.Sin(angle);
        Vector3 rowsOrigin = new Vector3(px, raycastOrigins.BottomCenter.y, pz);*/
        Vector3 rowsOrigin = perpVector * (horizontalRadius);
        rx = rowsOrigin.x + rowsOriginCenter.x;
        rz = rowsOrigin.z + rowsOriginCenter.z;
        rowsOrigin = new Vector3(rx, rowsOriginCenter.y, rz);
        //print("dirXZ=" + dirXZ.ToString("F4") + "; perpVector=" + perpVector + ";rowsOrigin="+rowsOrigin);
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = new Vector3(rowsOrigin.x, rowsOrigin.y + (i * horizontalRowSpacing), rowsOrigin.z);
            //print("horizontalRowSpacing= " + horizontalRowSpacing + "; rowOrigin = " + rowOrigin.ToString("F4"));
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                //o=(rowOrigin.x,rowOrigin.z), f=(fx,fz), r=(perpVector2.x,perpVector2.z)
                //(perpVector2.x,perpVector2.z)=(fx-rowOrigin.x,fz-rowOrigin.z)
                Vector3 finalRowDir = rowDir * (j * horizontalRaySpacing);
                float fx = finalRowDir.x + rowOrigin.x;
                float fz = finalRowDir.z + rowOrigin.z;
                Vector3 rayOrigin = new Vector3(fx, rowOrigin.y, fz);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, dirXZ * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, dirXZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    //print("HIT AGAINST " + hit.collider.gameObject.name);
                    //print("DISTANCE HIT = " + hit.distance);
                    if (hit.distance > (skinWidth))
                    {
                        print("HIT DISTANCE= " + hit.distance);
                        Vector3 aux = dirXZ.normalized * (hit.distance - skinWidth);
                        vel = new Vector3(aux.x, vel.y, aux.z);
                        rayLength = hit.distance;
                    }
                    else
                    {
                        //calculate parallel direction to plane hit and percentage of magnitude, based on incidence angle (90º->0)
                        Vector3 normal = new Vector3(hit.normal.x, 0, hit.normal.z);
                        Vector3 parallel = -normal;
                        //angle
                        float cos = Vector3.Dot(dirXZ, normal);
                        float cosDeg = Mathf.Acos(cos) * Mathf.Rad2Deg;
                        float prop = ((cosDeg - 90) / 90);
                        prop = Mathf.Clamp(prop, 0, 1);
                        float finalSpeed = vel.magnitude * prop;
                        vel = new Vector3(parallel.x * finalSpeed, vel.y, parallel.z * finalSpeed);
                        print("HIT ANGLE = " + cosDeg + "; PARALLEL DIR= " + parallel.ToString("F4") + "; FINAL SPEED= " + finalSpeed);
                    }

                    collisions.behind = directionZ == -1;
                    collisions.foward = directionZ == 1;
                    collisions.left = directionX == -1;
                    collisions.right = directionX == 1;
                }
                //if (i == 0) { break; }
            }
        }
    }//No se usa

	    void VerticalCollisions(ref Vector3 vel)
    {
        // ---------------------- 3D "CAPSULE" -------------------
        float directionY = Mathf.Sign(vel.y);
        float rayLength = Mathf.Abs(vel.y) + skinWidth;
        Vector3 rowsOrigin = directionY == -1 ? raycastOrigins.BottomLFCorner : raycastOrigins.TopLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);
            //print("i= " + i + "; Radius = " + radius);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j + vel.x), rowOrigin.y, rowOrigin.z + vel.z);

                RaycastHit hit;
                //Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt != MovingState.descending)
                    {
                        //print("VERTICAL COLLISIONS");
                        vel.y = (hit.distance - skinWidth) * directionY;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                            horVel = horVel.normalized * (vel.y / Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad));
                            vel = new Vector3(horVel.x, vel.y, horVel.z);
                        }
                        collisions.below = directionY == -1;
                        collisions.above = directionY == 1;
                    }
                }
            }
            if (collisions.moveSt == MovingState.climbing && collisions.slopeAngle != collisions.slopeAngleOld)//new slope, being on a slope already.This avoids going into the slope b4 adapting to new slope.
            {
                Vector3 horVel = new Vector3(vel.x, 0, vel.z);
                rayLength = horVel.magnitude + skinWidth;
                Vector3 rayOrigin = collisions.closestHorRaycast.origin + Vector3.up * vel.y;//NEEDS TO BE FIXED, the real ray origin should be  = BottomCenter + horVel.normalized * radius - skinWidth;
                RaycastHit hit;
                if (Physics.Raycast(rayOrigin, horVel.normalized, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
                    if (slopeAngle != collisions.slopeAngle)
                    {
                        Vector3 newHorVel = (hit.distance - skinWidth) * horVel.normalized;
                        collisions.slopeAngle = slopeAngle;
                    }
                }
            }
        }
    }//No se usa

    void XCollisions(ref Vector3 vel)
    {
        float directionX = Mathf.Sign(vel.x);
        float rayLength = Mathf.Abs(vel.x) + skinWidth;
        Vector3 rowsOrigin = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = rowsOrigin;
            rowOrigin.y = rowsOrigin.y + i * horizontalRowSpacing;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOrigin = rowOrigin + Vector3.back * (j * horizontalRaySpacing + vel.y);
                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.right * directionX * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.right * directionX, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt == MovingState.none || slopeAngle > maxClimbAngle)
                    {
                        vel.x = (hit.distance - skinWidth) * directionX;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            vel.y = Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(vel.x);
                        }
                        collisions.left = directionX == -1;
                        collisions.right = directionX == 1;
                    }

                }
            }
        }
    }//No se usa

    void ZCollisions(ref Vector3 vel)
    {
        float directionZ = Mathf.Sign(vel.z);
        float rayLength = Mathf.Abs(vel.z) + skinWidth;
        Vector3 rowsOrigin = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
        for (int i = 0; i < horizontalRows; i++)
        {
            Vector3 rowOrigin = rowsOrigin;
            rowOrigin.y = rowsOrigin.y + i * horizontalRowSpacing;
            for (int j = 0; j < horizontalRaysPerRow; j++)
            {
                Vector3 rayOrigin = rowOrigin + Vector3.right * (j * horizontalRaySpacing + vel.y);
                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.forward * directionZ * rayLength, Color.red);
                //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.forward * directionZ, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (collisions.moveSt == MovingState.none || slopeAngle > maxClimbAngle)
                    {
                        vel.z = (hit.distance - skinWidth) * directionZ;
                        rayLength = hit.distance;

                        if (collisions.moveSt == MovingState.climbing)
                        {
                            vel.y = Mathf.Tan(collisions.slopeAngle * Mathf.Deg2Rad) * Mathf.Abs(vel.z);
                        }
                        collisions.behind = directionZ == -1;
                        collisions.foward = directionZ == 1;
                    }
                }
            }
        }
    }//No se usa

	
    void ClimbSlopeCollisions(ref Vector3 vel)
    {
        float directionX = Mathf.Sign(vel.x);
        float rayLengthX = skinWidth;
        Vector3 rowOriginX = directionX == 1 ? raycastOrigins.BottomRFCorner : raycastOrigins.BottomLFCorner;
        for (int j = 0; j < horizontalRaysPerRow; j++)
        {
            Vector3 rayOriginX = rowOriginX + Vector3.back * (j * horizontalRaySpacing);
            RaycastHit hit;
            Debug.DrawRay(rayOriginX, Vector3.right * directionX * rayLengthX, Color.yellow);
            //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

            if (Physics.Raycast(rayOriginX, Vector3.right * directionX, out hit, rayLengthX, collisionMask, QueryTriggerInteraction.Ignore))
            {
                float slopeAngle = GetSlopeAngle(hit);
                if (hit.distance < collisions.closestHorRaycast.distance)
                {
                    float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                    collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginX, slopeAngle, wallAngle, Raycast.Axis.X);
                }
            }
        }
        float directionZ = Mathf.Sign(vel.z);
        float rayLengthZ = skinWidth;
        Vector3 rowOriginZ = directionZ == 1 ? raycastOrigins.BottomLFCorner : raycastOrigins.BottomLBCorner;
        for (int j = 0; j < horizontalRaysPerRow; j++)
        {
            Vector3 rayOriginZ = rowOriginZ + Vector3.right * (j * horizontalRaySpacing);
            RaycastHit hit;
            Debug.DrawRay(rayOriginZ, Vector3.forward * directionZ * rayLengthZ, Color.yellow);
            //print("rayOrigin= " + rayOrigin + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

            if (Physics.Raycast(rayOriginZ, Vector3.forward * directionZ, out hit, rayLengthZ, collisionMask, QueryTriggerInteraction.Ignore))
            {
                float slopeAngle = GetSlopeAngle(hit);
                if (hit.distance < collisions.closestHorRaycast.distance)
                {
                    float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                    collisions.closestHorRaycast = new Raycast(hit, hit.distance, vel, rayOriginZ, slopeAngle, wallAngle, Raycast.Axis.Z);
                }
            }
        }
        if (collisions.closestHorRaycast.axis != Raycast.Axis.none)// En otras palabras, si se ha movido y rellenado el valor de "closestHorRaycast"(hit)
        {
            if (collisions.closestHorRaycast.slopeAngle <= maxClimbAngle)
            {
                Vector3 horVel;
                float distanceToSlopeStart = 0;
                if (collisions.closestHorRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
                {//Substract the distance to slope from the velocity
                    distanceToSlopeStart = collisions.closestHorRaycast.distance - skinWidth;
                    horVel = new Vector3(vel.x, 0, vel.z);
                    horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                    vel = new Vector3(horVel.x, vel.y, horVel.z);
                }
                ClimbSlope(ref vel, collisions.closestHorRaycast);
                horVel = new Vector3(vel.x, 0, vel.z);
                horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
                vel = new Vector3(horVel.x, vel.y, horVel.z);
            }
        }
    }//No se usa

    void DescendSlopeCollisions(ref Vector3 vel)
    {
        float directionY = Mathf.Sign(vel.y);
        float rayLength = 1 + skinWidth;
        Vector3 rowsOrigin = raycastOrigins.BottomLFCorner;
        Vector3 rowOrigin = rowsOrigin;
        //print("----------NEW SET OF RAYS------------");
        for (int i = 0; i < verticalRows; i++)
        {
            rowOrigin.z = rowsOrigin.z - (verticalRowSpacing * i);
            //print("i= " + i + "; Radius = " + radius);

            for (int j = 0; j < verticalRaysPerRow; j++)
            {
                Vector3 rayOrigin = new Vector3(rowOrigin.x + (verticalRaySpacing * j), rowOrigin.y, rowOrigin.z);

                RaycastHit hit;
                Debug.DrawRay(rayOrigin, Vector3.up * directionY * rayLength, Color.yellow);
                //print("rayOrigin= " + rayOrigin + "; direction = " + directionY + "; rayLength = " + rayLength+"; BottomCenter.y= "+raycastOrigins.BottomCenter.y+"; min.y = "+coll.bounds.min.y);

                if (Physics.Raycast(rayOrigin, Vector3.up * directionY, out hit, rayLength, collisionMask, QueryTriggerInteraction.Ignore))
                {
                    float slopeAngle = GetSlopeAngle(hit);
                    if (hit.distance < collisions.closestVerRaycast.distance)
                    {
                        //print("NEW CLOSEST VERTRAY, slope angle= " + slopeAngle);
                        float wallAngle = Vector3.Angle(hit.normal, Vector3.forward);
                        collisions.closestVerRaycast = new Raycast(hit, hit.distance, vel, rayOrigin, slopeAngle, wallAngle, Raycast.Axis.Y);
                    }
                }
            }
        }

        if (collisions.closestVerRaycast.axis == Raycast.Axis.Y)// We are touching floor
        {
            if (CheckSlopeType(ref vel, collisions.closestVerRaycast) == MovingState.descending)
            {
                if (collisions.closestVerRaycast.slopeAngle <= maxDescendAngle)
                {
                    float distanceToSlopeStart = 0;
                    if (collisions.closestVerRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
                    {
                        print("NEW SLOPE DESCENDING slope angle= " + collisions.closestVerRaycast.slopeAngle + "; hit point =" + collisions.closestVerRaycast.ray.point.ToString("F4"));
                        distanceToSlopeStart = collisions.closestVerRaycast.distance - skinWidth;
                        vel.y -= distanceToSlopeStart * -1;
                    }
                    //print("DESCEND SLOPE");
                    DescendSlope(ref vel, collisions.closestVerRaycast);
                    vel.y += distanceToSlopeStart * -1;
                    //print("vel= " + vel.ToString("F5"));
                }
            }


            /*Vector3 horVel;
            float distanceToSlopeStart = 0;
            if (collisions.closestHorRaycast.slopeAngle != collisions.slopeAngleOld)//if new slope
            {//Substract the distance to slope from the velocity
                distanceToSlopeStart = collisions.closestHorRaycast.distance - skinWidth;
                horVel = new Vector3(vel.x, 0, vel.z);
                horVel = horVel.normalized * (horVel.magnitude - distanceToSlopeStart);
                vel = new Vector3(horVel.x, vel.y, horVel.z);
            }
            ClimbSlope(ref vel, collisions.closestHorRaycast);
            horVel = new Vector3(vel.x, 0, vel.z);
            horVel = horVel.normalized * (horVel.magnitude + distanceToSlopeStart);
            vel = new Vector3(horVel.x, vel.y, horVel.z);*/
        }
    }//No se usa
	
    void CylinderHorizontalCollisions(ref Vector3 vel)
    {
        Vector3 horVel = new Vector3(vel.x, 0, vel.z);
        float rayLength = horVel.magnitude + skinWidth;
        Vector3 rowOrigin = raycastOrigins.BottomCenter + (horVel.normalized * raycastOrigins.AroundRadius);
        for (int i = 0; i < horizontalRows; i++)
        {
            rowOrigin.y = raycastOrigins.BottomCenter.y + (i * horizontalRowSpacing);
            //for(int j=0; j<)
        }
    }//No se usa

	    /*
     public void PickFlag(GameObject _flag)
     {
         Flag auxFlag = _flag.GetComponent<Flag>();
         GameObject ownerFlag = _flag.GetComponent<Flag>().currentOwner;
         if (ownerFlag == null)
         {
             if (!haveFlag && ((!auxFlag.beingHooked) || (auxFlag.beingHooked && auxFlag.playerHooking != transform)))
             {
                 flag = _flag;
                 flag.transform.SetParent(rotateObj);
                 flag.transform.localPosition = new Vector3(0, 0, -0.5f);
                 flag.transform.localRotation = Quaternion.Euler(0, -90, 0);
                 haveFlag = true;
                 ownerFlag = gameObject;
             }
         }
     }

     public void StealFlag(Transform _flag)
     {
         Flag auxFlag = _flag.GetComponent<Flag>();
         GameObject ownerFlag = auxFlag = 

     }

     public void LoseFlag(PlayerMovement attacker)
     {
         if (haveFlag)
         {
             print("ROBA BANDERA");
             attacker.PickFlag(flag);
             flag = null;
             haveFlag = false;
         }
     }

     public void LoseFlag()
     {
         if (haveFlag)
         {
             flag.GetComponent<Flag>().currentOwner = null;
             flag.transform.SetParent(StoringManager.instance.transform);
             flag = null;
             haveFlag = false;
         }
     }*/

	 //WALL EDGE:
	        //Debug.LogError("WALL EDGE: collPoint1 = " + collisions.closestHorRaycast.ray.point.ToString("F4") + "; collPoint2 = " + differentWallRay.ray.point.ToString("F4") +
            //    "; vector1 = " + vector1 + "; vector2 = " + vector2 + "; angle1 = " + angle1 + "; angle1 = " + angle2 + "; angle1IsRight = " + angle1IsRight);
            //float edgeAngle = Vector3.SignedAngle(differentWallRay.ray.normal, collisions.closestHorRaycast.ray.normal,Vector3.up);
            //edgeAngle = Mathf.Sign(edgeAngle)*((360 - (Mathf.Abs(edgeAngle) * 2) )/ 2);
            //float angle1 = differentWallRay.wallAngle;
            //angle1 = Vector3.Angle(Vector3.right, differentWallRay.ray.normal)>=90? angle1 : -angle1;
            //float angle2 = collisions.closestHorRaycast.wallAngle;
            //angle2 = Vector3.Angle(Vector3.right, collisions.closestHorRaycast.ray.normal) >= 90 ? angle2 : -angle2;
            //edgeAngle = SignedAngleBetween(differentWallRay.ray.normal, collisions.closestHorRaycast.ray.normal, Vector3.up);

            //Vector3 wallVector1 = new Vector3(-differentWallRay.ray.normal.z, 0, differentWallRay.ray.normal.x).normalized;
            //Vector3 wallVector2 = new Vector3(-collisions.closestHorRaycast.ray.normal.z, 0, collisions.closestHorRaycast.ray.normal.x).normalized;
            //Debug.DrawRay(differentWallRay.origin,wallVector1*2,Color.black,3);
            //Debug.DrawRay(collisions.closestHorRaycast.origin, wallVector2*2, Color.black, 3);
            //Debug.LogWarning("WALL EDGE: collided with walls with angles: "+ angle1 + " and "+ angle2 + "; wallAngles = "+ wallVector1 +" and "+ wallVector2 +
            //    "; angle between them = " + edgeAngle);
            //if (edgeAngle < 0)
            //{
            //}